/*****************
 uboot启动流程 arm
 
 uboot的访问的地址为物理地址
*/

reset@start.S-->_main{
  //初始化
- board_init_f(ulong bootflag){
	  //遍历初始化。调用init_sequence中函数
	- for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) 
		- (*init_fnc_ptr)()
	- dram_init_banksize
	- display_dram_config
	}@board.c
 //BSS段 全局变量，静态变量初始完成。。进入大循环
- board_init_r(gd_t *id, ulong dest_addr){
	- enable_caches
	- serial_initialize
	- power_init_board
	- interrupt_init
	- enable_interrupts
	  //一般是用户初始化
	- board_late_init()
	- for (;;) {
		- main_loop();
		}
	}@board.c
}@crt0.S

main_loop{
- cli_init()
  //获取启动命令
- const char *s = bootdelay_process()
  //安全启动
- if (cli_process_fdt(&s))
	- cli_secure_boot_cmd(s)
  //执行启动命令
- autoboot_command-->run_command_list@autoboot.c-->cboot{
	  //获取启动模式
	- for (i = 0;  i < CHECK_BOOTMODE_FUN_NUM; i++)
		- bootmode = s_boot_func_array[i]()
	  //注册启动模式函数
	- board_boot_mode_regist{
		- MODE_REGIST(CMD_NORMAL_MODE, normal_mode) //2
		- MODE_REGIST(CMD_RECOVERY_MODE, recovery_mode) //3
		}@sp7731e_1h10.c
	  //执行对应的启动模式
	- boot_mode_array[bootmode]()-->
		normal_mode{//正常模式
		  //震动
		- vibrator_hw_init
		- set_vibrator(1)
		  //
		- vlx_nand_boot(BOOT_PART, BACKLIGHT_ON, LCD_ON)
		}@boot_mode.c
	}@cmd_cboot.c
}@main.c


vlx_nand_boot(char *kernel_pname, int backlight_set, int lcd_enable){
- wakeup_source_enable()
 //打开显示
- save_lcd_bpix_to_kernel(pic_bpix)
- drv_lcd_init()
- lcd_splash(LOGO_PART)
- lcd_enable()
 //加载kernel
- _boot_load_kernel_ramdisk_image(kernel_pname, hdr, &dt_adr){
	  //根据启动模式加载分区
	- if (0 == memcmp(bootmode, RECOVERY_PART, strlen(RECOVERY_PART))) {
		- partition = "recovery"
	  }else{
		- partition = "boot"
		}
	- _get_kernel_ramdisk_dt_offset(hdr, partition) //读取头信息
	- common_raw_read(partition, size, (uint64_t)(boot_img_offset.kernel_offset) , (char *)KERNEL_ADR)){//读取kernel镜像
		- 
		}
	}
}@loader_nvm.c

arch/arm/cpu/armv7/start.S
arch/arm/lib/crt0.S
arch/arm/lib/board.c
common/main.c
common/autoboot.c
common/loader/boot_mode.c
common/loader/loader_nvm.c
/*****************
 uboot命令：(命令实现位置common/cmd_xxx.c)
*/

命令定义：
#define U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \
cmd_tbl_t __u_boot_cmd_##name Struct_Section = {#name, maxargs, rep/*自动重复执行？*/, cmd, usage, help}

board/rockchip/common/armlinux/command.h

执行命令：
run_command_list-->builtin_run_command_list{
- 循环取出命令
- 执行，builtin_run_command{
	- 命令为空或长度超出范围，返回。
	- 处理命令串，查找“；”且该字符不在引号中。表示一个命令结束	
	- 替换命令中的宏，process_macros
	- 处理获取的命令，parse_line{//循环处理一行命令，取出其中的命令，参数
		- 跳过空白字符
		- 找到一个参数开始，argv[nargs++] = line
		- 找到第一个空白字符，设置为"\0"
		- 处理下个参数
		}
	- 执行命令，cmd_process{
		- 命令表cmd_tbl_t中，查找命令，find_cmd-->find_cmd_tbl
		- 判断命令参数个数是否正确。防止bootd命令递归
		- 执行，cmd_call{
			- (cmdtp->cmd)(cmdtp, flag, argc, argv)			
			}
		}@command.c
	}
}@main.c


common/main.c
common/command.c
/*****************
 输出函数：
*/
printf{
- 解析参数，vscnprintf
- 输出，puts{
	- 若配置CONFIG_SILENT_CONSOLE，或CONFIG_DISABLE_CONSOLE，则检测是否不输出
	- 没有控制台！gd->have_console，则输出到buffer中pre_console_puts
	- 输出到标准输出，fputs-->stdio_devices[file]->puts
	- 直接输出到串口，serial_puts
	}

}@console.c


//设置输入输出设备：
console_setfile{
- 设置设备，stdio_devices[file] = dev
- 设置函数gd->jt[XF_getc]，gd->jt[XF_putc]
}
common/console.c

//注册输入输出设备：
stdio_register (struct stdio_dev * dev)-->list_add_tail(&(_dev->list), &(devs.list)@stdio.c

//初始化：
drv_system_init{
- 初始化默认输出设备“serial”,dev.putc = serial_putc...
- 注册stdio_register
}

serial_putc-->get_current()->putc(c)-->default_serial_console(获取到已经实现的串口设备)@serial.c
drivers/serial/serial.c

/*****************
  参数传递到kernel

  arm中将dtb或者taggedlist在内存中的物理地址写入r2寄存器。
  kernel根据地址addr+0x4 中的值判断时dtb(0xd00dfeed)还是taglist
*/

//Command line


//ATAG





//Device Tree





/*****************
 加载kernel：


*/

//制作启动kernel
保证liunx下机器的定义(include/asm-ppc/tqm8xx.h)包含uboot中开发板的信息(include/asm-<arch>/u-boot.h)。
同时保证IMAP_ADDR与uboot中CONFIG_SYS_IMMR是相同的。

要有root设备(根文件系统？？)

编译镜像：
* build a standard "vmlinux" kernel image (in ELF binary format):

* convert the kernel into a raw binary image:

	${CROSS_COMPILE}-objcopy -O binary  -R .note -R .comment -S vmlinux linux.bin

* compress the binary image:

	gzip -9 linux.bin

* package compressed binary image for U-Boot:

	mkimage -A ppc -O linux -T kernel -C gzip \
		-a 0 -e 0 -n "Linux Kernel Image" \
		-d linux.bin.gz uImage

mkimage可以用来制作ramdisk镜像，可以与kernel合并成一个文件也可分开。


//启动
main_loop@mian.c--getenv("bootcmd")--run_command-->do_bootm-->bootm_start-->boot_get_kernel
-->image_get_kernel(校验头信息和数据)@cmd_bootm.c

bootm_start{
- 获取变量是否校验kernel,getenv_yesno
- 获取内核，boot_get_kernel{
		- 
	}

- 获取文件系统，boot_get_ramdisk@image.c
}@cmd_boom.c-->



