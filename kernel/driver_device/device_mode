/***********************
 bus
*/
struct bus_type {
	struct device		*dev_root;
	int (*match)(struct device *dev, struct device_driver *drv) //用来匹配设备和驱动
	int (*probe)(struct device *dev)
}
struct bus_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct bus_type *bus, char *buf);
	ssize_t (*store)(struct bus_type *bus, const char *buf, size_t count);
};

///bus_type注册
int __must_check bus_register(struct bus_type *bus){
- struct subsys_private *priv = kzalloc(sizeof(struct subsys_private))
- priv->subsys.kobj.kset = bus_kset
- kset_register(&priv->subsys)
- bus_create_file(bus, &bus_attr_uevent)-->sysfs_create_file//bus属性文件
}

void bus_unregister(struct bus_type *bus)

/***********************
 classs
*/

struct class {
	const char		*name;
	struct module		*owner;
	struct kobject		*dev_kobj;
}
struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *class, struct class_attribute *attr,
			char *buf);
	ssize_t (*store)(struct class *class, struct class_attribute *attr,
			const char *buf, size_t count);
}

class_register-->__class_register(struct class *cls, struct lock_class_key *key){
- struct subsys_private *cp =kzalloc(sizeof(*cp))
- cp->subsys.kobj.ktype = &class_ktype
- kset_register(&cp->subsys)
- add_class_attrs(class_get(cls){
	 //遍历cls->class_attrs
	- class_create_file(cls, &cls->class_attrs[i])-->class_create_file_ns-->sysfs_create_file_ns //创建sysfs
	}
}@class.c
void class_unregister(struct class *class)


/***********************
 device
 创建设备时包含calss,字符设备编号,也可以创建字符设备.
 需要注册struct file_operations.讲devt和file_operations关联

*/
struct device {
	struct device *parent;
	struct kobject kobj;
	struct bus_type	*bus;
	struct device_driver *driver;
	dev_t			devt //sysfs devt
}

struct device_attribute {
	struct attribute	attr;
	ssize_t (*show)(struct device *dev, struct device_attribute *attr,
			char *buf);
	ssize_t (*store)(struct device *dev, struct device_attribute *attr,
			 const char *buf, size_t count);
}

DEVICE_ATTR_RW(uevent){
- uevent_show
- uevent_store
}

//创建device包含char_dev
struct device *device_create(struct class *class, struct device *parent,
			     dev_t devt, void *drvdata, const char *fmt, ...)
-->device_create_vargs-->device_create_groups_vargs
{
- struct device *dev= kzalloc(sizeof(*dev)
- device_initialize(dev)
- dev->devt = devt
- dev->class = class
- device_add(dev) //加入
}

//加入设备
int device_add(struct device *dev){
- dev = get_device(dev)
- dev_set_name //设置kobject name
- kobject_add(&dev->kobj, dev->kobj.parent)  //加入kobj
- device_create_file(dev, &dev_attr_uevent)-->sysfs_create_file //创建device属性文件,包含字符设备编号
- device_add_attrs
- bus_add_device(dev)
- if(MAJOR(dev->devt)){
	- device_create_file(dev, &dev_attr_dev)
	- device_create_sys_dev_entry(dev)
	}
}@core.c


//驱动与设备匹配：@driver/base
//设备注册：
device_register(struct device *dev){
- device_initialize(dev){
	- dev->kobj.kset = devices_kset //kset
	- kobject_init(&dev->kobj, &device_ktype)//kobject
	- device_pm_init(dev)
	}
- device_add(dev){
	- kobject_add(&dev->kobj, dev->kobj.parent)
	- device_create_file(dev, &dev_attr_uevent)
	- device_add_attrs(dev)
	- kobject_uevent(&dev->kobj, KOBJ_ADD) //设备时间
	- bus_probe_device //探测设备驱动
	}

}@core.c

//查找设备对应的驱动
bus_probe_device(struct device *dev)-->device_initial_probe(dev)@bus.c
-->device_initial_probe(struct device *dev)-->__device_attach(dev, true)-->
__device_attach(struct device *dev, bool allow_async){
- if (dev->driver) {//已经绑定了驱动
	- device_bind_driver(dev)
 }else{
	- bus_for_each_drv(dev->bus, NULL, &data,__device_attach_driver)
 }
}@dd.c

__device_attach_driver(struct device_driver *drv, void *_data){
- driver_match_device(drv, dev){
	- drv->bus->match(dev, drv)
	}
 //是否异步probe
- async_allowed = driver_allows_async_probing(drv)
 //马上probe。和driver注册一样
- driver_probe_device(drv, dev)
}@dd.c

kernel/include/linux/device.h
kernel/drivers/base/bus.c
kernel/drivers/base/class.c
kernel/drivers/base/core.c

