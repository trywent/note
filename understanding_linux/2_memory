/******************
 memory
*/
﻿逻辑地址-->GDT(全局描述符表)或LDT(局部描述符表)-->线性地址
线性地址-->分页表-->物理地址


三种类型地址：
逻辑地址：在机器语言的指令中，用来说明操作数和指令的地址。(汇编程序中的地址)
线性地址(虚拟地址):包含所有的可寻址范围
物理地址：实际地址，对应产生的电信号

地址的转换过程：
逻辑地址--段单元-->虚拟地址--分页单元-->物理地址

/*
 分段的硬件实现：
*/
段地址：段选择器+偏移地址

段选择器由专有的寄存器保存，CS(有两个标识，表示当前运行的级别)，DS，SS


//断描述符：
保存在GDT(全局描述符表)或LDT(局部描述符表)。GDT地址和大小保存在gdtr，LDT保存在ldtr。
为加快地址转换速度。在段寄存器装入段选择符时，有一个非编程寄存器自动存放段描述符。

逻辑地址：转换线性地址
段选择符装入到段寄存器(cs,ds,ss..)时，相应的断描述符也会被装入到对应的寄存器中(段描述符包含线性地址...,转换成线性地址通过该值加上offset)
转换步骤：
1，根据TI(表索引)查找描述符在哪个描述符表中（GDT，LDT）
2，根据index（*8，描述符长度为8byte），获得描述符地址
3，将逻辑地址偏移量与描述符字段base相加，获得线性地址

//linux2.6中只有80x86需要使用分段

linux中用户态所有进程使用相同一对断__USER_CS,__USER_DS，内核态的进程也是用相同的一对断进行寻址
__KERNEL_CS,__KERNEL_DS。
linux下逻辑地址中的偏移量与线性地址的值是相同的（因为段地址的线性地址都从0x0000000开始）

LINUX GDT:
多处理器系统中每个cpu对应一个GDT，GDTS存放在cpu_gdt_table数组中.GDTS的地址和大小保存在cpu_gdt_descr
GDT包含18个断描述符和14个null（高速缓存时对齐，要32byte，描述符8byte），不同的断描述符定义了不同功能的断(相当根据不同的应用功能，将内存做了初步划分)
18个段描述符：
- 用户空间和内核空间的，代码段数据段。
- Task State Segment(TSS),每个处理器都有一个。对应的线性地址在，内核数据段的线性地址中
- 默认的Local Descriptor Table(LDT),所有的进程共享
- 3个Thread-local Storage(TLS),用于存放线程本地变量
- 3个Advance Power Mangerment(APM),BIOS代码使用的段
- 5个段与Plug and Play(PnP)BIOS服务相关
- 一个特殊的TSS，用于“Double Fault”异常

每个处理器保存了一个GDT的副本(其中有些段描述符是不同的，如TSS)


LINUX LDT:
不是每个用户态程序需要LDT，所以linux提供共享的LDT存放在default_table数组中。
可以使用modify_ldt()创建自定义的LDT
/*
 硬件中的分页：
*/

//页 一个页对应的空间一般为4k
线性地址被分为固定长度的组，称为页。内存上一个页大小的块称为页框(内存上的概念)。

//页表 每个进程维护一个页表2^20x4 = 4M大小
将线性地址映射到物理地址的数据结构称为页表(page table)，页表中存放有相应的物理地址。
80x86中通过设置cr0寄存器中PG标志位启用分页。当PG=0，线性地址被解释为物理地址。

线性地址-->分页单元，获取对应的物理地址(请求是否合法,否则产生page fault)-->物理地址+页中偏移值(12 bits)。将线性地址转换成物理地址

//常规分页4K：
Directory:10（对应页表目录）  Table:10（对应页表）  offset:12（地址在页表中的位置0～4096）
正在使用的页目录物理地址存放在cr3中。

每个进程维护一个页表，页表并不是一次分配完，而是需要时才分配的。(页表空间是动态分配,减少每个进程中的分页表所占的内存)
一个进程中页表占用的最大空间:2^20 x 4(一个页的物理地址4bytes)=4M
一页对应的内存大小：2^12 = 4k

//扩展分页：(设置cr4中的PSE标识位使能)
允许页框大小为4M。节省页表所占空间
Directory:10   offset:22

硬件保护机制：
分页中的权限有USER/SuperVisor标识控制（0是kernel,1是用户）。read/write权限(0只读，1读写)

地址分配示例：
- 内核决定某段线性地址分配给某个进程
- 见进程中对应的page Directory，赋值指向对应页表page tables
- 对应的page tables中赋值对应物理地址。其他没有使用的赋值为0

当页表中的present为0时，进程访问该页表将发生page fault错误。所以进程不能访问没有分配的线性地址。

//物理地址扩展(PAEs)：
为了增加内存的大小，将处理器引脚从32增加到36位（64GB）。从而页框数从2^20增加到2^24(页框大小不变)。
页表项大小从32位变为64为(实际使用36位)
通过设置cr4中pae标志位，启用物理地址扩展（PAE）。增加四个脚，2^36（原来2^32）
页框数增加到2^24次方，页框大小不变（4kB,2^12）。页表项中指向物理地址字段的长度增加4位，变成24bit(匹配页框数)。总长变为36，实际操作时变为64bit。页表项增大一倍。

在内核寻址中，并没有增加线性地址的大小。寻址过程中加入cr3寄存器中指向的四个页表项
cr3    PDPT(页目录指针表)
31-30  PDPT中4项中一个
29-21  目录项
20-12  页表项
11-10  页框中偏移地址
还是32位地址，寻址4GB。通过改变cr3能够寻址64GB的所有内存

//64位系统分页：
采用多级分页，防止页表过多各架构的分页方式不同

//硬件高速缓存：
高速缓存内存，高速缓存控制器。内存中存放缓存的行，控制器中有一个表项数组
每个表项对应一个行。表项包括一个标签tag和几个标志flag。标签可以用来确定对应的内存中的行

转换后援缓冲器(TLB,translation lookaside buffer):
用于加快线性地址的转换，当地址第一次慢速从RAM中表项中计算出来后，会被保存在TLB

/*
 LINUX中的分页
 每个进程有自己的page global directory和page table。当进程切换时会将cr3寄存器中的值，更新为当前进程的页表地址。

*/
//linux2.6.11 采用4级分页。页框4k(12bits)
- page global directory	//页全局目录   10bits 一般总位数-前面占用
- page upper directory	//页上级目录   0bits   
- page middle directory	//页中间目录   0bits   
- page table		//页表	      10bits  9bits(64)

32位地址。使用2级，中间两项为0 //10 10 12(偏移)
32位地址(打开PAE)。使用3级    //
64位地址。使用4级	     //10 


//物理内存布局：
在内核初始化阶段，内核要建立物理内存映射，确定那些物理内存范围可用。
//内核将下列页框记为保留（不能动态分配或交换到磁盘上）：
- 在不可用的物理地址范围内的页框
- 含有内核代码和初始化数据的页框

若一个页框为4k，
{
- machine_specific_memory_setup //确定物理地址的分配
- setup_memroy  		 //初始化物理地址相关的变量
}

/*
 进程页表：

 用户空间只能访问 0x00000000 ~ 0xbfffffff
 内核空间可以访问所有地址（应该是通过mmap映射，用户空间线性地址对应的的物理地址）
*/
//进程的线性地址空间分为两部分：
0x00000000 ~ 0xbfffffff 用户态和内核态都可寻址（3GB）
0xc0000000 ~ 0xffffffff 内核可寻址（1GB）

//进程的页全局目录：
低于0xc0000000时每个进程的页表映射的物理地址都不一样。高于0xc0000000的映射物理地址都是一样(kernel空间)

PAE没有启用：用户空间在前768个项（两级页目录，页表：2^10=1024 个页表项。2^10 * 2^10 * 4K=4G）
PAE启用：用户空间在前3个项(三级：4*512*512 4K)
-------------------------
内核页表（为普通进程提供页全局目录模板）：master kernel page global diretory

内核初始化自己页表的步骤(临时页表全局目录保存在swapper_pg_dir)：
1- 临时页表{  //先初始化一段空间，仅kernel的代码数据等..既能通过物理地址访问，又能通过线性地址访问
 - 将内核代码，数据所在的page物理地址设置到页表中
   //第0，768(3g开始地址)设置为一样。使得分页启前后，物理地址，线性地址都能访问到同一个物理地址
 - 设置相关flag
}

2，kernel使用全部的内存，并设置页表
startup_32{
- 页表初始化 
- 改函数会启用分页单元,cr3存入swapper_pg_dir，cr0写入PG标记
}@arch/i386/kernel.head.s

------------------------
内核映射：必须把0xc0000000映射到物理地址

当内存小于896M时，所有的内存都映射到内核地址空间。当大于896M小于4096M时，只映射896M地址到内核地址空间。
在大于896M时，要访问其它的内存需要动态映射。

//内存初始化。PC内核通常存放在开始的1M空间之后
1，内核获取所有的硬件地址空间(可用的硬件地址)
2，

/*

 mmap
 程序开始运行时，系统如何给程序分配空间，分页是如何进行。程序中执行malloc如何分配空间
*/
内存映射：
#include <sys/mman.h>
void *mmap(void *addr, size_t length, int prot, int flags,int fd, off_t offset);
int munmap(void *addr, size_t length);

映射只能是页大小sysconf(_SC_PAGE_SIZE)
mmap函数应该不能用来修改文件大小（就算映射大于文件时（补0），对超出文件大小的内存操作不会影响文件内容）。
mmap的使用应该仅是修改文件已有的内容。
prot说明映射的内存的权限（读，写，执行，访问）
flags是否修改对别的进程可见(修改文件，不仅仅修改内存。修改时打开的文件权限需要可写)

//原理
1 内核分配用户空间的虚拟地址 //这个地址用户用来访问映射的数据 vm_area_struct
2 分配物理地址映射到虚拟地址 //将页表映射到虚拟地址，remap_pfn_range
3 关联文件和物理地址。当访问该页内容时文件内容被装入(缺页异常)


//访问物理地址
phys_to_virt	//内存地址空间
ioremap		//io寄存器地址

