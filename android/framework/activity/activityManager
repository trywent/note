/***********************
 activityManagerService启动

*/
systemReady{
- 是否有升级进行处理，mDidUpdate
- 检测mPidsSelfLocked中不允许运行的进程，
- 杀死procsToKill中进程，removeProcessLocked
- 获取设置，retrieveSettings
- 发送广播，ACTION_USER_STARTED/ACTION_USER_STARTING
-  mStackSupervisor.resumeTopActivitiesLocked
}

//更新应用配置
updateConfiguration{
- values = mWindowManager.computeNewConfiguration() //计算配置
- updateConfigurationLocked(values){
	- mSystemThread.applyConfigurationToResources
	- 遍历mLruProcesses{//遍历最近进程,更新资源
	- ProcessRecord app = mLruProcesses.get(i)
	- app.thread.scheduleConfigurationChanged(Configuration)-->
		handleConfigurationChanged@ActivityThread.java--applyConfigurationToResourcesLocked(config)
		}
- mWindowManager.setNewConfiguration //更新窗口配置
}@ActivityManagerService.java


//启动launcher：
resumeTopActivitiesLocked@ActivityStackSupervisor.java-->resumeTopActivityLocked
@ActivityStack.java-->resumeHomeActivity@ActivityStackSupervisor.java
-->
startHomeActivityLocked{
- getHomeIntent
- 解析activityInfo，resolveActivityInfo
- 获取进程getProcessRecordLocked，
- 进程为空则启动，mStackSupervisor.startHomeActivity
}


finishBooting{
- 设置系统属性，SystemProperties.set("sys.boot_completed", "1")
- 发送启动完成广播broadcastIntentLocked(ACTION_BOOT_COMPLETED)
}

/***********************
 启动Activity流程
*/
启动的activity结束后，可以返回结果到启动activity：startActivityForResult
sendActivityResultLocked-->r.app.thread.scheduleSendResult@ActivityStack.java-->(跨进程)
ApplicationThread.scheduleSendResult-->queueOrSendMessage(H.SEND_RESULT)-->mH.sendMessage
H.handleMessage(SEND_RESULT)-->handleSendResult(先将activity暂停，再发送结果)-->deliverResults
-->r.activity.dispatchActivityResult@ActivityThread.java-->onActivityResult@Activity.java

启动activity:
startActivityMayWait-->startActivityLocked{
-查找到返回结果的activityRecord
-创建ActivityRecord
}
-->startActivityUncheckedLocked{
1. Flag要求新task，如果不要求返回启动结果，则首先查找其他task中是否有已启动的acivity。
2. 判断activity是否已经在stack顶部,则直接恢复 
3. *是否新建task，将task移到stack顶部 *启动activity存在，将新activity加入到启动activity的task中 
   *没有启动activity，且不是一个新task，则直接加入到最上的task中
}
-->startActivityLocked{
-存在于已有的task，现在不显示actvity，则加入栈mHistory，并向windowManagerService加入应用标记		     
  mService.mWindowManager.addAppToken
-有多个activity，判断设置切换动画，并加入应用标记addAppToken
-没有其他activity，加入应标记addAppToken
-在这里会检查是否要延迟5s启动，是则将记录加入mPendingActivityLaunches
}
-->resumeTopActivityLocked(null)-->resumeTopActivityLocked(
- 获取栈顶的ActivityRecord，若为空则启动launcher
- 取得的AcivityRecord是否是已经是mResumedActivity，则返回(已经显示了)
- 若正在睡眠且，activity状态是正确。把余留的动画执行完，则返回
- 若正在暂停activity，则等待暂停执行完成
- 使当前mResumedActivity暂停。
- 设置应用的状态不为stoped
- 准备切换动画，mService.mWindowManager.prepareAppTransition
- activity的应用和进程已经启动，
	mService.mWindowManager.setAppVisibility;开始显示
	updateOrientationFromAppTokens()重新计算方位，若配置变了要重新开始acivity。			 
		执行ensureActivitiesVisibleLocked，并返回
	scheduleSendResult();发送执行结果
	scheduleResumeActivity();执行恢复应用	
	completeResumeLocked;启动完成，更新状态
- activity进程没有启动，则startSpecificActivityLocked //启动Activity进程
}
-->completeResumeLocked-->ensureActivitiesVisibleLocked-->executeAppTransition@ActivityStack.java-->
executeAppTransition(进行窗口切换)@WindowManagerService.java

//启动Activity进程
startSpecificActivityLocked{
-进程开始了，执行realStartActivityLocked
-应用进程没有开始，执行开始进程mService.startProcessLocked
}
-->startProcessLocked{
Intent.FLAG_FROM_BACKGROUND  //操作是从后台进程发起的，用户不可见的进程发起的操作

-是否已经存在应用进程信息，是则向ProcessRecord加入应用信息，返回
-应用不是单独进程，若该应用进程在坏进程列表中，是从后台发起且则直接返回，非后台发起则清楚坏进程标记(让用户可见出错消息)
-新建newProcessRecordLocked，加入应用信息
}
-->startProcessLocked{
-根据用户id，组id开始新进程。Process.start
-将应用进程ProcessRecord加入到mPidsSelfLocked。并发送进程启动初始处理消息
}
-->Process.start("android.app.ActivityThread",)-->main()-->new ActivityThreadd().attach(false)
-->mgr.attachApplication@ActivityThread.java-->attachApplication
-->attachApplicationLocked{
-设置processRecord中值，Thread设为当前线程...
-确保apk包被解析，ensurePackageDexOpt
-绑定进程，初始化进程上下文。bindApplication-->handleBindApplication@ActivityThread.java
-检查是否有actviity,service,broadcastReceiver在等待该进程，运行这些组件
}
-->mMainStack.realStartActivityLocked@ActivityManagerService.java



//启动进程后：
(应用端回调)-->attachApplication-->attachApplicationLocked{
- app.makeActive(thread, mProcessStats)
- 启动等待的actvitiy，mStackSupervisor.attachApplicationLocked
- 启动服务，mServices.attachApplicationLocked
}

暂停：
activityPaused-->stack.activityPausedLocked@ActivityManagerService.java-->
activityPausedLocked-->completePauseLocked@ActivityStack.java


//创建栈：
createStack(int taskId, int relativeStackBoxId, int position, float weight){
- 创建新栈，mStackSupervisor.createStack
- 窗口服务端创建栈，mWindowManager.createStack
- 任务id不为0，将对应的任务移动到新栈，moveTaskToStack
}

设置焦点：
setFocusedStack-->setFocusedActivityLocked{
- 设置焦点栈，mStackSupervisor.setFocusedStack
- 设置焦点应用， mWindowManager.setFocusedApp
}

_______________
最近任务：mRecentTasks
systemReady{
- 从data/system/recent_tasks,restoreTasksLocked
- 从data/system/restored_recent_tasks,restoreTasksFromOtherDeviceLocked
}@TaskPersister.java

addRecentTaskLocked
addAppTask

frameworks/base/services/core/java/com/android/server/am/TaskPersister.java


/***********************
 应用程序进程状态
*/
应用崩溃：
dvmDetachCurrentThread-->threadExitUncaughtException-->dvmCallMethod(..uncaughtHandler...)
@Thread.cpp-->Thread.getDefaultUncaughtExceptionHandler().uncaughtException
@RemoteViewsService.java-->uncaughtException@RuntimeInit.javahandleApplicationCrash-->
handleApplicationCrashInner/handleApplicationWtf-->crashApplication{
- 
- 是否记录，makeAppCrashingLocked-->handleAppCrashLocked
}@ActivityManagerService.java

//应用die
attachApplicationLocked-->thread.asBinder().linkToDeath(new AppDeathRecipient)
AppDeathRecipient.binderDied-->appDiedLocked-->handleAppDiedLocked-->
mStackSupervisor.resumeTopActivitiesLocked



frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
frameworks/base/core/java/com/android/internal/os/RuntimeInit.java


anr:
notifyANR@InputMonitor.java-->saveANRState@ActivityManagerService.java
