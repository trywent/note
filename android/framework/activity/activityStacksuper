/***********************
 stackSupervisor,管理stack

*/







/*
 idle
 处理mStoppingActivities,mFinishingActivities.
*/
processStoppingActivitiesLocked(ActivityRecord idleActivity){
- allResumedActivitiesVisible
  //遍历mStoppingActivities
- ActivityRecord s = mStoppingActivities.get
- removeTimeoutsForActivityLocked(idleActivity)
- scheduleIdleTimeoutLocked(idleActivity)
}@ActivityStackSupervisor.java

//从应用端回调
activityIdle(IBinder token)-->mStackSupervisor.activityIdleInternalLocked@ActivityManagerService.java
//ActivityService调用pause后,进入idle超时
ActivityStackSupervisorHandler.handleMessage(IDLE_TIMEOUT_MSG/IDLE_NOW_MSG)-->activityIdleInternal-->
activityIdleInternalLocked@ActivityStackSupervisor.java

activityIdleInternalLocked(IBinder token){
- ActivityRecord r = ActivityRecord.forTokenLocked(token)
- r.idle = true //actvityRecord idle状态
- if(allResumedActivitiesIdle){
	- ensureActivitiesVisibleLocked(null)
	}
- ArrayList<ActivityRecord> stops = processStoppingActivitiesLocked(r)
- ArrayList<ActivityRecord> finishes = new ArrayList<>(mFinishingActivities)
  //遍历stop,执行finish或者stop
- 若是finish,stack.finishCurrentActivityLocked(r)
  else stopActivityLocked@ActivityStack.java
  //遍历finish,执行destroy
- stack.destroyActivityLocked(r)
- resumeFocusedStackTopActivityLocked
}ActivityStackSupervisor.java


=====================
配置改变：
ensureActivityConfigurationLocked

setPackageScreenCompatModeLocked@CompatModePackages.java
restartPackage@ActivityStack.java

/*
 task管理

*/
task:
startActivityUncheckedLocked{
- 创建新task，r.setTask(targetStack.createTaskRecord)
}

移除task：
destroyActivityLocked-->removeActivityFromHistoryLocked@ActivityStack.java-->
removeTask@ActivitySupervisor.java

mTaskHistory


/*
 stack管理

*/

//创建
createStack{
- 创建栈，mStackSupervisor.createStack-->new ActivityStack@ActivityStackSupervisor.java
- 创建栈窗口区域，mWindowManager.createStack
}@ActivityManagerService.java

//移除
removeTask-->mStacks.remove

//调整
startActivityUncheckedLocked-->adjustStackFocus(ActivityRecord){
- 若是应用activity{
	- 若ActivityRecord.task不为空则返回task.stack。并设置mFocusedStack
	- ActivityRecord.task为空，但mFocusedStack不为空，则返回mFocusedStack
	- mFocusedStack为空则遍历mStacks，并返回
	- 创建新stack，mService.createStack{
		- 创建stackid，mStackSupervisor.createStack
		- 创建窗口服务端stack，createStack
		}
	}
- 返回homestack
}




=====================
调整焦点栈：
removeTask

//查找activity对应的栈
startActivityUncheckedLocked-->adjustStackFocus{
- 查找并设置，mFocusedStack
}


设置状态：
//触摸设置焦点栈：
displayContent.mTapDetector(TAP_OUTSIDE_STACK)@StackTapPointerEventListener.java
-->setFocusedStack@WindowManagerService.java-->setFocusedStack-->setFocusedActivityLocked
@WindowManagerService.java-->setFocusedStack{
- 若不是应用栈，mStackState(若home栈不为in_front,则设为to_front)
- 若是应用栈，设置mFocusedStack，mStackState(若home栈不为in_back,则设为to_back)
}@ActivityStackSupervisor.java

//acvitiy启动完成
allResumedActivitiesComplete{
- mStackState（若是to_back,则设置in_back）
- mStackState（若是to_front,则设置in_front）
}

//移动homestack
startActivityUncheckedLocked(启动应用时设置)-->moveHomeStack{
- 设置mStackState
}@ActivityStackSupervisor.java
====================
//焦点应用
startActivityUncheckedLocked-->setFocusedActivityLocked@ActivityStackSupervisor.java

adjustFocusedActivityLocked-->setFocusedActivityLocked@ActivityStack.java

frameworks/base/services/java/com/android/server/am/ActivityStackSupervisor.java
frameworks/base/services/java/com/android/server/am/ActivityStack.java


