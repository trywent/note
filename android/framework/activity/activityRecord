/**************************
 ActivityRecord

*/

enum ActivityState {
        INITIALIZING,
        RESUMED,
        PAUSING,
        PAUSED,
        STOPPING,
        STOPPED,
        FINISHING,
        DESTROYING,
        DESTROYED
    }
//创建controller
createWindowContainer(){
- TaskWindowContainerController taskController = task.getWindowContainerController()
- updateOverrideConfiguration
- mWindowContainerController = new AppWindowContainerController(taskController, appToken...)
}@ActivityRecord.java

//设置启动窗口
showStartingWindow(ActivityRecord prev, boolean newTask, boolean taskSwitch, boolean fromRecents){
- CompatibilityInfo compatInfo = service.compatibilityInfoForPackageLocked
- boolean shown = mWindowContainerController.addStartingWindow(packageName, theme,
	compatInfo, nonLocalizedLabel, labelRes, icon, logo...)
- 
}@ActivityRecord.java




/******************
 设置可见.AppWindowTokenController-->AppWindowToken-->WindowState-->(应用进程)ViewRootImpl
*/
makeVisibleIfNeeded(ActivityRecord starting, boolean reportToClient) {
- setVisible(true){
	- visible = newVisible
	- mDeferHidingClient = !visible && mDeferHidingClient
	- setVisibility(visible)
	}
  //发送消息到client
- makeClientVisible(){
	- mAtmService.getLifecycleManager().scheduleTransaction(app.getThread(), appToken,
                    WindowVisibilityItem.obtain(true /* showWindow */))
	- makeActiveIfNeeded(null)
	}
- handleAlreadyVisible()
}

setVisibility(boolean visible){
- mWindowContainerController.setVisibility-->setVisibility@AppWindowTokenController.java
}@ActivityRecord.java

onWindowsVisible{
- nowVisible = true
- if (idle || mStackSupervisor.isStoppingNoHistoryActivity()) {	//有其它activity等待当前activity可见
	- mStackSupervisor.mActivitiesWaitingForVisibleActivity.clear()
	- mStackSupervisor.scheduleIdleLocked(
  }else{
	- mStackSupervisor.processStoppingActivitiesLocked
  }
}ActivityRecord.java


/*****************
 activity状态更新
*/
shouldResumeActivity(ActivityRecord activeActivity) {
- shouldMakeActive(activeActivity)			//检查是否栈顶位置
- isFocusable
}

shouldPauseActivity(ActivityRecord activeActivity) {
- shouldMakeActive(activeActivity)
- !isFocusable
}

//可见时，设置状态resume 或者 paused
makeActiveIfNeeded(ActivityRecord activeActivity) {
- if (shouldResumeActivity(activeActivity)) {		//是否设置active状态(resume)
	- getActivityStack().resumeTopActivityUncheckedLocked(activeActivity,null)
  }else if (shouldPauseActivity(activeActivity)) {	//是否设置pause
	- setState(PAUSING, "makeVisibleIfNeeded")
  }
}

setState(ActivityState state, String reason) {
- mState = state
  //通知parent状态，activityStack根据这个设置mResumedActivity
- TaskRecord parent = getTaskRecord()
- parent.onActivityStateChanged(this, state, reason)
  //stoping时detach子窗口
- if (state == STOPPING && !isSleeping()) {		
	- mAppWindowToken.detachChildren
	}
}


/***********************
 生命周期
*/
mWaitingVisibleActivities  	//等待activity可见后才执行操作的activities
mWaitingActivityVisible    	//等待activity启动可见结果的进程集合
mWaitingActivityLaunched   	//等待activity启动完成结果的进程集合
mStoppingActivities      	//将要执行stop的activity
mFinishingActivities     	//将要结束的activity

onCreate - onDestroy 		//完整生命周期
onStart - onStop  		//可见
onResume - onPause 		//用户可交互


/* INITIALIZING


*/
ActivityRecord(ActivityManagerService _service, Intent _intent,ActivityInfo aInfo,....) {
- ActivityManagerService service = _service;
- IApplicationToken.Stub  appToken = new Token(this);
- info = aInfo;
- state = INITIALIZING;
}@ActivityRecord.java


/* PAUSED

*/
//启动过程中设置初始状态为PAUSED
realStartActivityLocked(ActivityRecord r, ProcessRecord app,boolean andResume, boolean checkConfig){
- 
- if (andResume && readyToResume()) {
	- stack.minimalResumeActivityLocked(r)
  }else{
	- r.state = PAUSED
  }
}@ActivityStackSupervisor.java


relaunchActivityLocked(boolean andResume, boolean preserveWindow){
- startFreezingScreenLocked(app, 0)
- if(andResume){

  }else{
	- state = PAUSED
  }
}@ActiviyRecord.java

//Activity执行完成PAUSE
activityPaused(IBinder token)-->stack.activityPausedLocked(token)@ActivityManagerService.java-->
activityPausedLocked(IBinder token){
- ActivityRecord r = isInStackLocked(token)
- mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r)
- if (mPausingActivity == r){
	- completePauseLocked(true)
  }else{
	- r.state = ActivityState.PAUSED;
	- finishCurrentActivityLocked
	}
- mStackSupervisor.ensureActivitiesVisibleLocked(null)
}@ActivityStack.java

completePauseLocked(boolean resumeNext){
- ActivityRecord prev = mPausingActivity
- prev.state = ActivityState.PAUSED //设置状态为PAUSED
- if(prev.app!=null){
	- mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(prev)
	- if(prev.deferRelaunchUntilPaused){
		-  prev.relaunchActivityLocked(false /* andResume */,...)
	  }else if(wasStopping){
		- prev.state = STOPPING
	  }else if(!prev.visible || shouldSleepOrShutDownActivities()){
	  	  //加入到STOPPING
		- addToStopping
	  }	
   }
- if(resumeNext){
	- 
	}
}@ActivityStack.java


/* RESUMED


*/

resumeTopActivityInnerLocked-->
setResumedActivityLocked(ActivityRecord r, String reason){
- mResumedActivity = r
- r.state = ActivityState.RESUMED
}@ActivitStack.java


//通知应用端
resumeTopActivityInnerLocked-->scheduleResumeActivity@ActivitStack.java

/* PAUSING
  调用schedulePauseActivity,当app执行pause完成后,resumeTop

*/
resumeTopActivityInnerLocked-->
startPausingLocked(boolean userLeaving, boolean uiSleeping,ActivityRecord resuming, boolean pauseImmediately){
- ActivityRecord prev = mResumedActivity	//当前要执行pause的Activity
- mPausingActivity = prev
- prev.state = ActivityState.PAUSING		//设置activityRecord状态为PAUSING
- prev.app.thread.schedulePauseActivity-->ActivityManagerNative.getDefault().activityPaused //app执行pause
  //app执行pause完成返回
- if pauseImmediately(boolean resumeNext){
	- 
	- ensureActivitiesVisibleLocked	
  } else schedulePauseTimeout(prev)
}@ActivityStack.java






/* STOPING

   mStackSupervisor.mStoppingActivities 保存要stopping的activity
*/

//将不可见的Activity才加入mStackSupervisor.mStoppingActivities。在全屏activity后面不可见
//等idle时执行stop流程
ensureActivitiesVisibleLocked-->
makeInvisible(ActivityRecord r){
- r.setVisible(false)
- switch(r.state){
	- STOPPING,STOPPED:{//通知应用窗口隐藏了
		- r.app.thread.scheduleWindowVisibility(r.appToken, false)
		}
	- INITIALIZING,RESUMED,PAUSING,PAUSED:{
		- addToStopping(r, true)
		}
	}
}@ActivityStack.java



//设置STOPING状态，通知应用stop
activityIdleInternalLocked@ActivityStackSupervisor.java-->
stopActivityLocked{
- 
- if (r.app != null && r.app.thread != null) {
	- r.stopped = false
	- r.state = STOPPING
	- r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags)
	- mHandler.sendMessageDelayed(STOP_TIMEOUT_MSG, STOP_TIMEOUT) //stop超时
  }
  //停止出错
- r.stopped = true
- r.state = STOPPED
- destroyActivityLocked
}@ActivityStack.java

//结束activity
finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj) {
- ActivityRecord next = mStackSupervisor.topRunningActivityLocked()
- if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible)
                && next != null && !next.nowVisible) {
	- r.state = STOPPING
	}
}@ActivityStack.java


/* STOPPED

 
*/


//Activity执行完成stop
activityStopped(IBinder token, Bundle icicle..)@ActivityManangerService.java-->
activityStoppedLocked(Bundle newIcicle, PersistableBundle newPersistentState,) {
- if (!stopped) {
	- stopped = true
	- state = STOPPED
	- mWindowContainerController.notifyAppStopped()
	- 
	}
}@ActvityRecored.java
/* FINISHING


*/
finish-->ActivityManagerNative.getDefault().finishActivity@Activity.java-->
finishActivity@ActivityManagerService.java-->requestFinishActivityLocked-->
finishActivityLocked{
- 标记activity正在结束，makeFinishing
- adjustFocusedActivityLocked
- startPausingLocked
- 若没有暂停，直接结束finishCurrentActivityLocked
}@ActivityStack.java

finishCurrentActivityLocked{
- 当前结束activity是显示状态，addToStopping,加入mStoppingActivities推迟结束
- 已经是stop状态，destroyActivityLocked
- 非stop，{
	- 加入mFinishingActivities
	- getFocusedStack().resumeTopActivityLocked
	}
}@ActivityStack.java


/* DESTROYING

*/


/* DESTROYED

*/




frameworks/base/services/core/java/com/android/server/am/ActivityRecord.java
frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java
