/***********************

*/
mWaitingVisibleActivities  //等待activity可见后才执行操作的activities
mWaitingActivityVisible    //等待activity启动可见结果的进程集合
mWaitingActivityLaunched   //等待activity启动完成结果的进程集合
mStoppingActivities      //将要执行stop的activity
mFinishingActivities     //将要结束的activity

onCreate - onDestroy //完整生命周期
onStart - onStop   //可见
onResume - onPause //用户可交互


/* INITIALIZING


*/
ActivityRecord(ActivityManagerService _service, Intent _intent,ActivityInfo aInfo,....) {
- ActivityManagerService service = _service;
- IApplicationToken.Stub  appToken = new Token(this);
- info = aInfo;
- state = INITIALIZING;
}@ActivityRecord.java


/* PAUSED

*/
//Activity执行完成PAUSE
activityPaused(IBinder token)-->stack.activityPausedLocked(token)@ActivityManagerService.java-->
activityPausedLocked(IBinder token){
- ActivityRecord r = isInStackLocked(token)
- mHandler.removeMessages(PAUSE_TIMEOUT_MSG, r)
- if (mPausingActivity == r){
	- completePauseLocked(true)
  }else{
	- r.state = ActivityState.PAUSED;
	- finishCurrentActivityLocked
	}
- mStackSupervisor.ensureActivitiesVisibleLocked(null)
}@ActivityStack.java

completePauseLocked(boolean resumeNext){
- ActivityRecord prev = mPausingActivity
- prev.state = ActivityState.PAUSED //设置状态为PAUSED
- if(prev.app!=null){
	- mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(prev)
	- if(prev.deferRelaunchUntilPaused){
		-  prev.relaunchActivityLocked(false /* andResume */,...)
	  }else if(wasStopping){
		- prev.state = STOPPING
	  }else if(!prev.visible || shouldSleepOrShutDownActivities()){
	  	  //加入到STOPPING
		- addToStopping
	  }	
   }
- if(resumeNext){
	- 
	}
}@ActivityStack.java


//启动过程中设置初始状态为PAUSED
realStartActivityLocked(ActivityRecord r, ProcessRecord app,boolean andResume, boolean checkConfig){
- 
- if (andResume && readyToResume()) {
	- stack.minimalResumeActivityLocked(r)
  }else{
	- r.state = PAUSED
  }
}@ActivityStackSupervisor.java


relaunchActivityLocked(boolean andResume, boolean preserveWindow){
- startFreezingScreenLocked(app, 0)
- if(andResume){

  }else{
	- state = PAUSED
  }
}@ActiviyRecord.java

/* RESUMED


*/

resumeTopActivityInnerLocked-->
setResumedActivityLocked(ActivityRecord r, String reason){
- mResumedActivity = r
- r.state = ActivityState.RESUMED
}@ActivitStack.java


//通知应用端
resumeTopActivityInnerLocked-->scheduleResumeActivity@ActivitStack.java

/* PAUSING
  调用schedulePauseActivity,当app执行pause完成后,resumeTop

*/
resumeTopActivityInnerLocked-->
startPausingLocked(boolean userLeaving, boolean uiSleeping,ActivityRecord resuming, boolean pauseImmediately){
- ActivityRecord prev = mResumedActivity	//当前要执行pause的Activity
- mPausingActivity = prev
- prev.state = ActivityState.PAUSING		//设置activityRecord状态为PAUSING
- prev.app.thread.schedulePauseActivity-->ActivityManagerNative.getDefault().activityPaused //app执行pause
  //app执行pause完成返回
- if pauseImmediately(boolean resumeNext){
	- 
	- ensureActivitiesVisibleLocked	
  } else schedulePauseTimeout(prev)
}@ActivityStack.java






/* STOPING

   mStackSupervisor.mStoppingActivities 保存要stopping的activity
*/

//将不可见的Activity才加入mStackSupervisor.mStoppingActivities。在全屏activity后面不可见
//等idle时执行stop流程
ensureActivitiesVisibleLocked-->
makeInvisible(ActivityRecord r){
- r.setVisible(false)
- switch(r.state){
	- STOPPING,STOPPED:{//通知应用窗口隐藏了
		- r.app.thread.scheduleWindowVisibility(r.appToken, false)
		}
	- INITIALIZING,RESUMED,PAUSING,PAUSED:{
		- addToStopping(r, true)
		}
	}
}@ActivityStack.java



//设置STOPING状态，通知应用stop
activityIdleInternalLocked@ActivityStackSupervisor.java-->
stopActivityLocked{
- 
- if (r.app != null && r.app.thread != null) {
	- r.stopped = false
	- r.state = STOPPING
	- r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags)
	- mHandler.sendMessageDelayed(STOP_TIMEOUT_MSG, STOP_TIMEOUT) //stop超时
  }
  //停止出错
- r.stopped = true
- r.state = STOPPED
- destroyActivityLocked
}@ActivityStack.java

//结束activity
finishCurrentActivityLocked(ActivityRecord r, int mode, boolean oomAdj) {
- ActivityRecord next = mStackSupervisor.topRunningActivityLocked()
- if (mode == FINISH_AFTER_VISIBLE && (r.visible || r.nowVisible)
                && next != null && !next.nowVisible) {
	- r.state = STOPPING
	}
}@ActivityStack.java


/* STOPPED

 
*/


//Activity执行完成stop
activityStopped(IBinder token, Bundle icicle..)@ActivityManangerService.java-->
activityStoppedLocked(Bundle newIcicle, PersistableBundle newPersistentState,) {
- if (!stopped) {
	- stopped = true
	- state = STOPPED
	- mWindowContainerController.notifyAppStopped()
	- 
	}
}@ActvityRecored.java
/* FINISHING


*/
finish-->ActivityManagerNative.getDefault().finishActivity@Activity.java-->
finishActivity@ActivityManagerService.java-->requestFinishActivityLocked-->
finishActivityLocked{
- 标记activity正在结束，makeFinishing
- adjustFocusedActivityLocked
- startPausingLocked
- 若没有暂停，直接结束finishCurrentActivityLocked
}@ActivityStack.java

finishCurrentActivityLocked{
- 当前结束activity是显示状态，addToStopping,加入mStoppingActivities推迟结束
- 已经是stop状态，destroyActivityLocked
- 非stop，{
	- 加入mFinishingActivities
	- getFocusedStack().resumeTopActivityLocked
	}
}@ActivityStack.java


/*
 DESTROYING

*/


/*
 DESTROYED

*/


/**************************
 configuration
 每个ActivityStack拥有一个mOverrideConfig,分屏时每个stack中的窗口都不一样
 将stack中的mOverrideConfig应用到栈中的每个应用
*/
resizeStackLocked{
- overrideConfig = mWindowManager.resizeStack(stackId, bounds) //获取新配置
- updateOverrideConfiguration(overrideConfig)-->mOverrideConfig= overrideConfig@ActivityStack.java//更新配置
}ActivityStackSupervisor.java

//更新配置
ensureActivityConfigurationLocked-->scheduleActivityConfigurationChanged(mOverrideConfig)
@ActivityStack.java

//更新配置
relaunchActivityLocked-->scheduleRelaunchActivity(mConfiguration,mOverrideConfig)@ActivityStack.java

/*
 resumeTop
 
*/

resumeTopActivityLocked{
- 获取栈顶的ActivityRecord，topRunningActivityLocked
- 若栈顶为空则启动launcher，mStackSupervisor.resumeHomeActivity
- 若需resume的activity已经在栈顶{
	- 执行窗口切换，mWindowManager.executeAppTransition
	- mNoAnimActivities.clear
	}
- 前一个resumed activity不为空{
	- 
	}
- 休眠状态，{
	- 执行完要执行的动画，mWindowManager.executeAppTransition
	- mNoAnimActivities.clear
	}
- 清除mStackSupervisor中activity的不对状态，mStoppingActivities,mGoingToSleepActivities
- 要暂停的activity是否完成，mStackSupervisor.allPausedActivitiesComplete
- 暂停当前已经resumed activity，startPausingLocked
- 由于睡眠设置了NO_HISTORY的activity没有结束，结束它requestFinishActivityLocked
- 上个activity不为空，且还是显示{
	- 
	- 当前activity已经显示，立即隐藏上个activity,mService.mWindowManager.setAppVisibility
	}
- 清除应用停止状态，AppGlobals.getPackageManager().setPackageStoppedState
- windowManger准备动画，prev不为空{
	- 状态为prev.finishing,设置动画mService.mWindowManager.prepareAppTransition(NONE/CLOSE)
	- 不为finishing,设置动画mService.mWindowManager.prepareAppTransition(NONE/OPEN)
	}else，栈不为空{
	- 设置动画mService.mWindowManager.prepareAppTransition(NONE/OPEN)
	}

- next的app和进程已经存在，{
	- 设置可见， mService.mWindowManager.setAppVisibility
	- 启动计时，startLaunchTickingLocked
	- 
	- 若是mMainStack更新配置，mService.mWindowManager.updateOrientationFromAppTokens
	}
- next没有被启动过,startSpecificActivityLocked
}@ActivityStack.java

