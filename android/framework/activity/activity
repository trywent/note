/***********************
 activity:生命周期 Created-----started(可见)-----Resumed-----Paused-----sopted-----destoryed
 
 Activity{//窗口
  ActivityThread --- IApplicationThread --- ActivityManagerService
  mToken  --- ActivitRecord.apptoken
  PhoneWindow --- decorView---ViewRootImpl --- ISession --- WindowManagerService 
 }

 ActivityRecord{//ActivityManagerService管理生命周期
	apptoken ---addApptoken--- WindowManagerService
	}

 ViewRootImpl{ //view布局,窗口变化
	session
	IWindow --- WindowManagerService
	}
 
*/
performLaunchActivity{
- Activity activity = mInstrumentation.newActivity
- activity.attach(appContext, this, getInstrumentation(), r.token....)
- int theme = r.activityInfo.getThemeResource()
- activity.setTheme(theme)
}@ActivityThread.java



attach(Context context, ActivityThread aThread,){
- mWindow = new PhoneWindow(this, window, activityConfigCallback) //创建窗口
- mWindow.setCallback(this)
- mWindow.setWindowManager(ontext.getSystemService(Context.WINDOW_SERVICE),mToken,appName)//创建当前窗口的windowManagerImpl.....
	-->setWindowManager{
	- mAppToken = appToken //设置token,,,源头ActivtyManager中activityRecord
	- mAppName = appName
	- wm.createLocalWindowManager(this/*parentWindow*/)-->new WindowManagerImpl(mContext, parentWindow)
	}@Window.java 
- mWindowManager = mWindow.getWindowManager()
}@Activity.java




==================
//activity启动流程


用户重写方法被调用流程：
performLaunchActivity@ActivityThread.java-->onCreate--performStart-->
mInstrumentation.callActivityOnStart@Activity.java-->callActivityOnStart-->
activity.onStart@Instrumentation.java-->onStart@Activity.java

------------------
//进入performLaunchActivity：
moveToState@LocalActivityManager.java-->startActivityNow-->performLaunchActivity@ActivityThread.java




__________________
//进入activityIdleInternal：
finishCurrentActivityLocked(ActivityRecord,int)-->finishCurrentActivityLocked-->:

checkReadyForSleepLocked-->:

resumeTopActivityLocked(将一activity置顶)-->(暂停当前activity)startPausingLocked-->
sendMessageDelayed-->handleMessage-->activityPaused-->completePauseLocked-->:

::scheduleIdleLocked-->mHandler.sendMessage(IDLE_NOW_MSG进入)-->handleMessage-->activityIdleInternal-->=

completeResumeLocked-->mHandler.sendMessage(IDLE_TIMEOUT_MSG进入)-->handleMessage-->activityIdleInternal-->=

==activityIdleInternal{


}-->resumeTopActivityLocked@ActivityStack.java
 

handleResumeActivity-->Looper.myQueue().addIdleHandler(new Idler())-->queueIdle-->
am.activityIdle@ActivityThread.java-->activityIdle@ActivityManagerService.java-->activityIdleInternal@ActivityStack.java

移除IDLE_TIMEOUT_MSG超时消息：
activityIdleInternal-->mHandler.removeMessages(IDLE_TIMEOUT_MSG, r)

-------------------
activity进入空闲：resume后可进入idle。(进入resume可以从onStart，或onPause)
handleLaunchActivity-->(从onStart到onResume)handleResumeActivity-->
Looper.myQueue().addIdleHandler(new Idler())(当MessageQueue空闲时执行)-->
am.activityIdle@ActivityThread.java-->activityIdle@ActivityManagerService.java-->
activityIdleInternal@ActivityStack.java

//更新启动intent
deliverNewIntent@ActivityStarter.java-->deliverNewIntentLocked@ActivityRecord.java-->
scheduleNewIntent-->handleNewIntent-->performNewIntents@ActivityThread.java

deliverNewIntents@ActiivtyThread.java-->callActivityOnNewIntent@Instrumentation.java-->
performNewIntent-->onNewIntent@Activity.java


frameworks/base/core/java/android/app/ActivityManagerNative.java
frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/java/com/android/server/am/ActivityStack.java
===================
事件：
处理后退按键：
onBackPressed-->finish-->(没有父activity)ActivityManagerNative.getDefault().finishActivity
@Activity.java-->finishActivity-->mMainStack.requestFinishActivityLocked@ActivityManagerService.java
-->finishActivityLocked-->finishActivityLocked-->finishActivityLocked-->resumeTopActivityLocked
@ActivityStack.java


onBackPressed-->finish-->(有父activity)mParent.finishFromChild-->finish@Activity.java

finishActivityLocked-->r.makeFinishing@ActivityStack.java

activityIdleInternal-->stopActivityLocked-->sendMessageDelayed(STOP_TIMEOUT_MSG)-->mHandler.handleMessage(STOP_TIMEOUT_MSG)-->activityStoppedLocked

_________________________________
back按键结束activity：

moveTaskToBack-->ActivityManagerNative.getDefault().moveActivityTaskToBack@Activity.java
-->moveActivityTaskToBack-->mMainStack.moveTaskToBackLocked@ActivityManagerService.java
-->moveTaskToBackLocked@ActivityStack.java


finish-->ActivityManagerNative.getDefault().finishActivity@Activity.java-->
finishActivity-->mMainStack.requestFinishActivityLocked@ActivityManagerService.java
-->requestFinishActivityLocked-->finishActivityLocked-->finishActivityLocked-->
finishCurrentActivityLocked-->resumeTopActivityLocked(恢复top位置activity)@ActivityStack.java


frameworks/base/core/java/android/app/Activity.java
frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/java/com/android/server/am/ActivityStack.java

================================
activity状态：

r.makeFinishing@ActivityStack.java-->makeFinishing@ActivityRecord.java
