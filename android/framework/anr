/* No response to an input event (such as key press or screen touch events) within 5 seconds.
   A BroadcastReceiver hasn't finished executing within 10 seconds.
*/
//android4.4  8
kill  -s 3 <pid>  

//android6,
kill -s 6 pid  //dump core logcat -s DEBUG'




appNotResponding(ProcessRecord app, ActivityRecord activity,
            ActivityRecord parent, boolean aboveSystem, final String annotation) {
- 
  //保存anr/trace.txt
- dumpStackTraces(boolean clearTraces, ArrayList<Integer> firstPids...){
	- String tracesDirProp = SystemProperties.get("dalvik.vm.stack-trace-dir", "")	//目录
	- if (tracesDirProp.isEmpty()) {
		- String globalTracesPath = SystemProperties.get("dalvik.vm.stack-trace-file", null)
		- tracesFile = new File(globalTracesPath)
		- tracesFile.createNewFile()
	  }else{
		- File tracesDir = new File(tracesDirProp)
		- tracesFile = createAnrDumpFile(tracesDir)
	  }
	- dumpStackTraces(tracesFile.getAbsolutePath(), firstPids, nativePids, extraPids)
	}@ActivityManagerService.java
  //创建信息
- StringBuilder info = new StringBuilder()
- mService.addErrorToDropBox("anr", app, app.processName, ..., tracesFile)
  //弹框
- makeAppNotRespondingLocked(app,...)
- Message msg = Message.obtain()
- msg.what = ActivityManagerService.SHOW_NOT_RESPONDING_UI_MSG
- mService.mUiHandler.sendMessage(msg)
}@AppErrors.java

//进程开始：
AndroidRuntime::startVm{
- opt.optionString= "-Xstacktracefile:"+ property_get("dalvik.vm.stack-trace-file");

}


frameworks/base/services/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/core/java/com/android/server/am/AppErrors.java
frameworks/base/core/jni/AndroidRuntime.cpp

/*
 input事件5s
*/
//超时时间
KEY_DISPATCHING_TIMEOUT = ActivityManager.isLowRamDeviceStatic()? 10*1000 : 8*1000;
@ActivityManagerService.java

handleTargetsNotReadyLocked-->onANRLocked-->doNotifyANRLockedInterruptible
@InputDispatcher.cpp-->notifyANR@InputManagerService.java-->notifyANRf{
- 应用不为空，appWindowToken.appToken.keyDispatchingTimedOut@InputMonitor.java-->
	keyDispatchingTimedOut-->service.inputDispatchingTimedOut(app,process)@ActivtyRecord.java
	-->appNotResponding@ActivityManagerService.java

- 窗口不为空， ActivityManagerNative.getDefault().inputDispatchingTimedOut(mPid)@InputMonitor.java
	-->appNotResponding@ActivityManagerService.java
}

inputDispatchingTimedOut{
- 
- mHandler.post-->mAppErrors.appNotResponding(proc, activity, parent, aboveSystem, annotation)
}@ActivityManagerService.java

frameworks/base/services/java/com/android/server/wm/InputMonitor.java
frameworks/base/services/java/com/android/server/input/InputManagerService.java
frameworks/base/services/input/InputDispatcher.cpp
frameworks/base/services/java/com/android/server/am/ActivityRecord.java

/* 
 广播10s
*/
//超时时间
static final int BROADCAST_FG_TIMEOUT = 20*1000;
static final int BROADCAST_BG_TIMEOUT = 90*1000;
@ActivityManagerService.java

processNextBroadcast{
- mParallelBroadcasts{//处理Parallel广播
	- deliverToRegisteredReceiverLocked
	}
- mOrderedBroadcasts{//只有这种类型广播才会超时
	- cancelBroadcastTimeoutLocked //处理完时取消超时广播
	}
- setBroadcastTimeoutLocked //开始处理设置超时广播
}

处理超时：
handleMessage(BROADCAST_TIMEOUT_MSG)-->broadcastTimeoutLocked{
- 在这里重设超时时间(广播接受者finish后没有取消超时){
	- mOrderedBroadcasts.get(0)
	- setBroadcastTimeoutLocked
	}
- AppNotResponding.run@BroadcastQueue.java-->mService.appNotResponding(mApp)
}BroadcastQueue.java

广播结束：
sendFinished-->am.finishReceiver@BroadcastReceiver.java-->finishReceiver{
- r.queue.finishReceiverLocked-->finishReceiverLocked@BroadcastQueue.java//
- r.queue.processNextBroadcast //处理下一个
}@ActivityManagerService.java


frameworks/base/services/java/com/android/server/am/BroadcastQueue.java

/* 服务10s

*/
//超时时间
static final int SERVICE_TIMEOUT = ActivityManager.isLowRamDeviceStatic() ? 40*1000 : 20*1000;
static final int SERVICE_BACKGROUND_TIMEOUT = SERVICE_TIMEOUT * 10;
static final int SERVICE_START_FOREGROUND_TIMEOUT = ActivityManager.isLowRamDeviceStatic() ? 10*1000 : 8*1000;
@ActiveServices.java

//启动服务
realStartServiceLocked{
- bumpServiceExecutingLocked(r, execInFg, "create")-->scheduleServiceTimeoutLocked{	//开始设置启动超时消息
	-  Message msg = mAm.mHandler.obtainMessage(ActivityManagerService.SERVICE_TIMEOUT_MSG)
	-  mAm.mHandler.sendMessageDelayed(msg,proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT)
	}	
- app.thread.scheduleCreateService(r, r.serviceInfo...)					//应用进程运行，执行启动流程
- requestServiceBindingsLocked(r, execInFg)
}
-->bumpServiceExecutingLocked(开始启动服务)

//启动完成取消超时：
scheduleBindService-->sendMessage(H.BIND_SERVICE, s)-->handleBindService-->
ActivityManager.getService().publishService@ActivityThread.java-->publishService@ActivityManagerService.java-->
publishServiceLocked-->serviceDoneExecutingLocked{
-->mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG)
}ActiveService.java


//start启动服务：
startService@ActivityManagerService.java-->startServiceLocked-->startServiceInnerLocked-->
bringUpServiceLocked-->sendServiceArgsLocked@ActivityService.java
scheduleServiceArgs-->handleServiceArgs{
- s.onStartCommand
- serviceDoneExecuting-->mServices.serviceDoneExecutingLocked
}@ActivityThread.java

//bind启动服务:
bindService@ActivityManagerService.java-->bindServiceLocked-->requestServiceBindingLocked-->
r.app.thread.scheduleBindService@ActivityService.java
scheduleBindService{
- s.onBind
- handleBindService-->ActivityManagerNative.getDefault().publishService-->
	mServices.publishServiceLocked-->serviceDoneExecutingLocked
}@ActivityThread.java

//超时处理：
MainHandler.handleMessage(SERVICE_TIMEOUT_MSG)-->mServices.serviceTimeout@ActivityManagerService.java


frameworks/base/services/java/com/android/server/am/ActiveServices.java
/*
 provider

*/
//超时时间
static final int CONTENT_PROVIDER_PUBLISH_TIMEOUT = SystemProperties.getBoolean("ro.config.low_ram", false) ? 20*1000 : 10*1000;
@ActivityManangerService.java


appNotRespondingViaProvider
inputDispatchingTimedOut


