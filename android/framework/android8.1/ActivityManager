/*服务启动

FIRST_STATIC_STACK_ID = 0
HOME_STACK_ID = FIRST_STATIC_STACK_ID                                    0:home luancher
FULLSCREEN_WORKSPACE_STACK_ID = 1                                        1:全屏应用位置
FREEFORM_WORKSPACE_STACK_ID = FULLSCREEN_WORKSPACE_STACK_ID + 1          2:free
DOCKED_STACK_ID = FREEFORM_WORKSPACE_STACK_ID + 1                        3:分屏应用
PINNED_STACK_ID = DOCKED_STACK_ID + 1                                    4:PIP  非focusable,不能设置为焦点栈
RECENTS_STACK_ID = PINNED_STACK_ID + 1                                   5:systemui中RecentsActivity
ASSISTANT_STACK_ID = RECENTS_STACK_ID + 1

//动态栈 从7开始
FIRST_DYNAMIC_STACK_ID = LAST_STATIC_STACK_ID + 1

*/
startBootstrapServices{
- mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService()
- mActivityManagerService.setSystemServiceManager(mSystemServiceManager)
- mActivityManagerService.setInstaller(installer)
}@SystemServer.java

startOtherServices-->mActivityManagerService.systemReady

/***********************
 设置WindowManager
 创建ActivityDisplay
 创建HOMEStack
*/
mActivityManagerService.setWindowManager(wm)@SystemServer.java-->setWindowManager{
- mWindowManager = wm
- mStackSupervisor.setWindowManager(wm){
	- mWindowManager = wm
	- mDisplayManager =(DisplayManager)getSystemService(Context.DISPLAY_SERVICE)
	- Display[] displays = mDisplayManager.getDisplays() //获取display个数
	- 遍历displays{
		- ActivityDisplay activityDisplay = new ActivityDisplay(displayId) //创建
		- mActivityDisplays.put(displayId, activityDisplay) 
		}	
	- mHomeStack = mFocusedStack = mLastFocusedStack =getStack(HOME_STACK_ID)//创建第一个stack
	}@ActivityStackSupervisor.java
- mActivityStarter.setWindowManager(wm){
	
	}
}@ActivityManagerService.java


//启动应用进程
resumeTopActivityInnerLocked@ActivityStack.java-->startSpecificActivityLocked@ActivityStackSupervisor.java-->
mService.startProcessLocked(r.processName, r.info.applicationInfo)@ActivityManangerService.java-->
startProcessLocked(processName,ApplicationInfo){
- ProcessRecord app
- !isolated{//非独立进程
	- app = getProcessRecordLocked(processName)
	}
- app==null,app = newProcessRecordLocked(info, processName){//创建ProcessRecord保存
	- ProcessRecord r = new ProcessRecord(stats, info)
	- addProcessNameLocked(r) 
	}
- startProcessLocked(app)-->
  startProcessLocked(ProcessRecord){
	- app.gids = gids
	- entryPoint = "android.app.ActivityThread" //进程入口
	- ComponentName cn = new ComponentName(app.info.packageName)
	- startResult = Process.start(entryPoint, app.processName, uid, uid, gids)
	}
}@ActivityManangerService.java

//关联进程
attachApplicationLocked{
 //监听进程是否挂了
- AppDeathRecipient adr = new AppDeathRecipient(app)
- thread.asBinder().linkToDeath(adr
- app.deathRecipient = adr

- thread.bindApplication(processName
}@ActivityManangerService.java

//binder监听进程挂
AppDeathRecipient.binderDied-->appDiedLocked-->appDiedLocked-->
handleAppDiedLocked{
- mStackSupervisor.handleAppDiedLocked(app)
- mStackSupervisor.resumeFocusedStackTopActivityLocked()
}@ActivityManangerService.java


 //应用进程native crash
startObservingNativeCrashes@SystemServier.java-->NativeCrashListener.run@ActivityManangerService.java
NativeCrashListener.run{
 //监听crash信息
- FileDescriptor serverFd = Os.socket(AF_UNIX, SOCK_STREAM)
- nixSocketAddress sockAddr = UnixSocketAddress.createFileSystem(DEBUGGERD_SOCKET_PATH)
- Os.bind(serverFd, sockAddr)
- Os.listen(serverFd)
 //应用崩溃
- consumeNativeCrashData-->NativeCrashReporter.start-->NativeCrashReporter.run-->mAm.handleApplicationCrashInner
	-->handleApplicationCrashInner
}@NativeCrashListener.java

/***********************
 ActivityStarter启动Activity
*/
startActivity-->startActivityForResult@Activity.java-->mInstrumentation.execStartActivity
-->execStartActivity@Instrumentation.java-->ActivityManager.getService().startActivity-->
startActivity(IBinder whoThread, String callingPackage,Intent intent, String resolvedType, Bundle bOptions,callingUser/*userId*/)
-->mActivityStarter.startActivityMayWait@ActivityManagerService.java-->
startActivityMayWait(caller,intent, null/*inTask*/){
- intent = new Intent(intent)
- ResolveInfo rInfo = mSupervisor.resolveIntent(intent)
- ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo
- startActivityLocked(caller, intent, aInfo, rInfo)
}@ActivityStarter.java

startActivityLocked(IApplicationThread caller, Intent intent, ActivityInfo aInfo, ResolveInfo rInfo){
- mLastStartActivityTimeMs = System.currentTimeMillis()
- mLastStartActivityResult = startActivity(caller, intent,aInfo, rInfo) 
}@ActivityStarter.java

//创建ActivityRecord
startActivity(IApplicationThread caller, Intent intent,ActivityInfo aInfo, ResolveInfo rInfo){
- abort = !mSupervisor.checkStartAnyActivityPermission //检测是否有启动权限
- ActivityRecord r = new ActivityRecord(mService, callerApp,callingPackage, intent) //创建ActivityRecord
- startActivity(r, sourceRecord, true, options, null/*inTask*/)-->startActivityUnchecked
}@ActivityStarter.java


startActivityUnchecked{
- setInitialState(r,options){
	- mStartActivity = r
	- mIntent = r.intent
	- mOptions = options
	- mLaunchBounds = getOverrideBounds(r, options, inTask) //options是否设置activity窗口范围
	- mLaunchFlags = adjustLaunchFlagsToDocumentMode
	}
- computeLaunchingTaskFlags //计算启动task
- computeSourceStack //获取源stack
- ActivityRecord reusedActivity = getReusableIntentActivity(){//找到已存在的task,返回该task的Activity...activity被启动过
	- 放到已有的task{
		- mLaunchSingleInstance,mSupervisor.findActivityLocked(mIntent, mStartActivity.info)-->
			findActivityLocked-->findActivityLocked@ActivityStack.java
		- mSupervisor.findTaskLocked-->findTaskLocked(ActivityRecord target)@ActivityStack.java//查找满足intent的task中top activity
		}
	}
  //已经启动过,使用已启动的Activity
- reusedActivity!=null{
	- reusedActivity = setTargetStackAndMoveToFrontIfNeeded
	- setTaskFromIntentActivity //设置task的创建Activity
	- resumeTargetStackIfNeeded
	}
- dontStart{ //已经启动
	- deliverNewIntent
	- mSupervisor.handleNonResizableTaskIfNeeded
	}
 //查找stack,创建task
- FLAG_ACTIVITY_NEW_TASK,setTaskFromReuseOrCreateNewTask{ //新task
	- mTargetStack = computeStackFocus(mStartActivity, mLaunchBounds)//获取stack
	}
- if(mSourceRecord != null)setTaskFromSourceRecord //从sourceRecord获取task
- if (mInTask != null)setTaskFromInTask
- setTaskToCurrentTopOrCreateNewTask//放到当前top task
  //启动
- mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask,mOptions) 1-->
- mDoResume{
	- !isFocusable{
		- mTargetStack.ensureActivitiesVisibleLocked
		- mWindowManager.executeAppTransition
		}
	- mSupervisor.resumeFocusedStackTopActivityLocked 2-->
	}
- mSupervisor.updateUserStackLocked
- mSupervisor.handleNonResizableTaskIfNeeded
}@ActivityStarter.java

-->1 startActivityLocked{
- 
- task.setFrontOfTask() //移动到栈顶
- 需要启动,设置动画{
	- mWindowManager.prepareAppTransition
	- r.setVisibility //设置可见
	}
}@ActivityStack.java

-->2 resumeFocusedStackTopActivityLocked-->
resumeFocusedStackTopActivityLocked{
- activity状态不是resumed,mFocusedStack.resumeTopActivityUncheckedLocked-->resumeTopActivityInnerLocked@ActivityStack.java
- activity状态是resumed,mFocusedStack.executeAppTransition
}@ActivityStackSupervisor.java



//pinnedStack activity启动通知
postStartActivityProcessing@ActivityStarter.java-->notifyPinnedActivityRestartAttempt@TaskChangeNotificationController.java


frameworks/base/services/core/java/com/android/server/am/TaskChangeNotificationController.java
/***********************
  stackSuperVisor
*/
//创建默认Display中stack
getStack(stackId){
- 若是DOCKED_STACK_ID,则需创建getStack(RECENTS_STACK_ID)
- createStackOnDisplay(stackId,DEFAULT_DISPLAY)-->createStack{
	- new PinnedActivityStack//PINNED_STACK_ID
	- new ActivityStack{
		- mHandler = new ActivityStackHandler
		- postAddToDisplay(display //加入到display
		}
	}
}@ActivityStackSupervisor.java


//主页
resumeHomeStackTask{
- mHomeStack.moveHomeStackTaskToTop()
- ActivityRecord r = getHomeActivity()
- moveFocusableActivityStackToFrontLocked(r)//设置焦点
- resumeFocusedStackTopActivityLocked(mHomeStack)
}


findActivityLocked(mIntent, mStartActivity.info){
- 遍历mActivityDisplays{
	- ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks
	-遍历 stacks{
	- ActivityRecord ar = stacks.get(stackNdx).findActivityLocked-->
		findActivityLocked{//从栈中查找
		- 
		}@ActivityStack.java
	}
}@ActivityStackSuperVisor.java

/***********************
  stack
*/

//resume
resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions){
- targetStack.resumeTopActivityUncheckedLocked //target不为空,且focusable(非pinstack)
- mFocusedStack.resumeTopActivityUncheckedLocked
}@ActivityStackSupervisor.java-->
resumeTopActivityUncheckedLocked-->resumeTopActivityInnerLocked{
- ActivityRecord next = topRunningActivityLocked
- mResumedActivity == next,executeAppTransition//已经为resumed状态
- mStackSupervisor.allPausedActivitiesComplete()//是否正在暂停
- mResumedActivity != null,startPausingLocked//需要暂停前一个ResumedActivity
 //隐藏前一个应用窗口
- prev != null{
	- activity.finishing,mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_CLOSE/TRANSIT_TASK_CLOSE) //设置动画
	- !activity.finishing,mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN/TRANSIT_TASK_OPEN_BEHIND/TRANSIT_TASK_OPEN)
  }else{
  	- mWindowManager.prepareAppTransition(TRANSIT_NONE/TRANSIT_ACTIVITY_OPEN)//设置动画
  }
 //进程启动.显示,设置状态当前resumedAcivity
- next.setVisibility(true)
- next.completeResumeLocked()
 //进程没有启动
- mStackSupervisor.startSpecificActivityLocked
}@ActivityStack.java



//显示
ensureActivitiesVisibleLocked{
 //遍历display
- int displayNdx = mActivityDisplays.size()
 //遍历stack
- stacks = mActivityDisplays.valueAt(displayNdx).mStacks
- ActivityStack stack = stacks.get(stackNdx)
- stack.ensureActivitiesVisibleLocked
}@ActivityStackSupervisor.java-->
ensureActivitiesVisibleLocked(ActivityRecord starting,int configChanges,boolean preserveWindows){
- 遍历task,TaskRecord task = tmpTaskHistory.get(taskNdx)
 //遍历ActivityRecord,
- ArrayList<ActivityRecord> activities = task.mActivities
- ActivityRecord r = activities.get(activityNdx)
- 显示reallyVisible,{
	- r.ensureActivityConfigurationLocked
	- r.makeVisibleIfNeeded
	}
- 隐藏!reallyVisible{
	- makeInvisible
	}
}@ActivityStack.java

//移动
setTargetStackAndMoveToFrontIfNeeded(reusedActivity){
- ActivityStack launchStack = getLaunchStack(),获取启动栈
- (launchStack == mTargetStack),mTargetStack.moveTaskToFrontLocked //启动栈和目标栈一致,移动task
- 
}

/***********************
  task
*/



//activityRecord
ensureActivityConfigurationLocked{
- updateOverrideConfiguration //获取最新配置
 //判断mLastReportedConfiguration和当前configuration是否一致
- mTmpConfig.setTo(mLastReportedConfiguration.getMergedConfiguration())
- getConfiguration().equals(mTmpConfig)
- setLastReportedConfiguration //发生变化,设置lastReport
- relaunchActivityLocked //relaunching non-resumed
}


/***********************
 焦点栈
*/
mHomeStack = mFocusedStack = mLastFocusedStack = getStack(HOME_STACK_ID) //初始为homeStack

moveToFront{
- mStacks.remove(this)
- mStacks.add(findStackInsertIndex(ON_TOP))//设置mStacks位置
- setFocusStackUnchecked-->设置mFocusedStack@ActivityStackSupervisor.java//设置焦点
}@ActivityStack.java






//force hide
pinnedStack.mForceHidden = true

frameworks/base/core/java/android/app/Activity.java
frameworks/base/core/java/android/app/Instrumentation.java
frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java
frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java
