/*服务启动

FIRST_STATIC_STACK_ID = 0
HOME_STACK_ID = FIRST_STATIC_STACK_ID                                    0:home luancher
FULLSCREEN_WORKSPACE_STACK_ID = 1                                        1:全屏应用位置
FREEFORM_WORKSPACE_STACK_ID = FULLSCREEN_WORKSPACE_STACK_ID + 1          2:free
DOCKED_STACK_ID = FREEFORM_WORKSPACE_STACK_ID + 1                        3:分屏应用
PINNED_STACK_ID = DOCKED_STACK_ID + 1                                    4:PIP  非focusable,不能设置为焦点栈
RECENTS_STACK_ID = PINNED_STACK_ID + 1                                   5:systemui中RecentsActivity
ASSISTANT_STACK_ID = RECENTS_STACK_ID + 1

//动态栈 从7开始
FIRST_DYNAMIC_STACK_ID = LAST_STATIC_STACK_ID + 1

*/
startBootstrapServices{
- mActivityManagerService = mSystemServiceManager.startService(ActivityManagerService.Lifecycle.class).getService()
- mActivityManagerService.setSystemServiceManager(mSystemServiceManager)
- mActivityManagerService.setInstaller(installer)
}@SystemServer.java

startOtherServices-->mActivityManagerService.systemReady

/***********************
 设置WindowManager
 创建ActivityDisplay
 创建HOMEStack
*/
mActivityManagerService.setWindowManager(wm)@SystemServer.java-->setWindowManager{
- mWindowManager = wm
- mStackSupervisor.setWindowManager(wm){
	- mWindowManager = wm
	- mDisplayManager =(DisplayManager)getSystemService(Context.DISPLAY_SERVICE)
	- Display[] displays = mDisplayManager.getDisplays() //获取display个数
	- 遍历displays{
		- ActivityDisplay activityDisplay = new ActivityDisplay(displayId) //创建
		- mActivityDisplays.put(displayId, activityDisplay) 
		}	
	- mHomeStack = mFocusedStack = mLastFocusedStack =getStack(HOME_STACK_ID)//创建第一个stack
	}@ActivityStackSupervisor.java
- mActivityStarter.setWindowManager(wm){
	
	}
}@ActivityManagerService.java

//创建默认Display中stack
getStack(stackId){
- 若是DOCKED_STACK_ID,则需创建getStack(RECENTS_STACK_ID)
- createStackOnDisplay(stackId,DEFAULT_DISPLAY)-->createStack{
	- new PinnedActivityStack//PINNED_STACK_ID
	- new ActivityStack{
		- mHandler = new ActivityStackHandler
		- postAddToDisplay(display //加入到display
		}
	}
}@ActivityStackSupervisor.java

/***********************
 ActivityStarter启动Activity
*/
startActivity-->startActivityForResult@Activity.java-->mInstrumentation.execStartActivity
-->execStartActivity@Instrumentation.java-->ActivityManager.getService().startActivity-->
startActivity(IBinder whoThread, String callingPackage,Intent intent, String resolvedType, Bundle bOptions,callingUser/*userId*/)
-->mActivityStarter.startActivityMayWait@ActivityManagerService.java-->
startActivityMayWait(caller,intent, null/*inTask*/){
- intent = new Intent(intent)
- ResolveInfo rInfo = mSupervisor.resolveIntent(intent)
- ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo
- startActivityLocked(caller, intent, aInfo, rInfo)
}@ActivityStarter.java

startActivityLocked(IApplicationThread caller, Intent intent, ActivityInfo aInfo, ResolveInfo rInfo){
- mLastStartActivityTimeMs = System.currentTimeMillis()
- mLastStartActivityResult = startActivity(caller, intent,aInfo, rInfo) 
}@ActivityStarter.java

//创建ActivityRecord
startActivity(IApplicationThread caller, Intent intent,ActivityInfo aInfo, ResolveInfo rInfo){
- abort = !mSupervisor.checkStartAnyActivityPermission //检测是否有启动权限
- ActivityRecord r = new ActivityRecord(mService, callerApp,callingPackage, intent) //创建ActivityRecord
- startActivity(r, sourceRecord, true, options, null/*inTask*/)-->startActivityUnchecked
}@ActivityStarter.java


startActivityUnchecked{
- setInitialState(r,options){
	- mStartActivity = r
	- mIntent = r.intent
	- mOptions = options
	- mLaunchBounds = getOverrideBounds(r, options, inTask) //options是否设置activity窗口范围
	- mLaunchFlags = adjustLaunchFlagsToDocumentMode
	}
- computeLaunchingTaskFlags //计算启动task
- computeSourceStack //获取源stack
- ActivityRecord reusedActivity = getReusableIntentActivity(){//找到已存在的task,返回该task的Activity...activity被启动过
	- 放到已有的task{
		- mLaunchSingleInstance,mSupervisor.findActivityLocked(mIntent, mStartActivity.info)-->
			findActivityLocked-->findActivityLocked@ActivityStack.java
		- mSupervisor.findTaskLocked-->findTaskLocked(ActivityRecord target)@ActivityStack.java//查找满足intent的task中top activity
		}
	}
  //已经启动过,使用已启动的Activity
- reusedActivity!=null{
	- reusedActivity = setTargetStackAndMoveToFrontIfNeeded
	- setTaskFromIntentActivity //设置task的创建Activity
	- resumeTargetStackIfNeeded
	}
- dontStart{ //已经启动
	- deliverNewIntent
	- mSupervisor.handleNonResizableTaskIfNeeded
	}
 //查找stack,创建task
- FLAG_ACTIVITY_NEW_TASK,setTaskFromReuseOrCreateNewTask{ //新task
	- mTargetStack = computeStackFocus(mStartActivity, mLaunchBounds)//获取stack
	}
- if(mSourceRecord != null)setTaskFromSourceRecord //从sourceRecord获取task
- if (mInTask != null)setTaskFromInTask
- setTaskToCurrentTopOrCreateNewTask//放到当前top task

- mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask,mOptions)
- mDoResume{
	- !isFocusable{
		- mTargetStack.ensureActivitiesVisibleLocked
		- mWindowManager.executeAppTransition
		}
	- mSupervisor.resumeFocusedStackTopActivityLocked
	}
- mSupervisor.updateUserStackLocked
- mSupervisor.handleNonResizableTaskIfNeeded
}@ActivityStarter.java


//pinnedStack activity启动通知
postStartActivityProcessing@ActivityStarter.java-->notifyPinnedActivityRestartAttempt@TaskChangeNotificationController.java


frameworks/base/services/core/java/com/android/server/am/TaskChangeNotificationController.java
/***********************
  stackSuperVisor
*/

findActivityLocked(mIntent, mStartActivity.info){
- 遍历mActivityDisplays{
	- ArrayList<ActivityStack> stacks = mActivityDisplays.valueAt(displayNdx).mStacks
	-遍历 stacks{
	- ActivityRecord ar = stacks.get(stackNdx).findActivityLocked-->
		findActivityLocked{//从栈中查找
		- 
		}@ActivityStack.java
	}
}@ActivityStackSuperVisor.java

/***********************
  stack
*/
//查找
computeStackFocus(mStartActivity, mLaunchBounds)
- 
}




//移动
setTargetStackAndMoveToFrontIfNeeded(reusedActivity){
- ActivityStack launchStack = getLaunchStack(),获取启动栈
- (launchStack == mTargetStack),mTargetStack.moveTaskToFrontLocked //启动栈和目标栈一致,移动task
- 
}

/***********************
  task
*/



//activityRecord
ensureActivityConfigurationLocked{
- updateOverrideConfiguration //获取最新配置
 //判断mLastReportedConfiguration和当前configuration是否一致
- mTmpConfig.setTo(mLastReportedConfiguration.getMergedConfiguration())
- getConfiguration().equals(mTmpConfig)
- setLastReportedConfiguration //发生变化,设置lastReport
- relaunchActivityLocked //relaunching non-resumed
}


/***********************
 焦点栈
*/
mHomeStack = mFocusedStack = mLastFocusedStack = getStack(HOME_STACK_ID) //初始为homeStack

moveToFront{
- mStacks.remove(this)
- mStacks.add(findStackInsertIndex(ON_TOP))//设置mStacks位置
- setFocusStackUnchecked-->设置mFocusedStack@ActivityStackSupervisor.java//设置焦点
}@ActivityStack.java


/***********************
 resume 显示
*/
//显示主页
resumeHomeStackTask{
- mHomeStack.moveHomeStackTaskToTop()
- ActivityRecord r = getHomeActivity()
- moveFocusableActivityStackToFrontLocked(r)//设置焦点
- resumeFocusedStackTopActivityLocked(mHomeStack)
}

//显示焦点栈中activity
resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions){
- targetStack.resumeTopActivityUncheckedLocked //target不为空,且focusable(非pinstack)
- mFocusedStack.resumeTopActivityUncheckedLocked
}@ActivityStackSupervisor.java-->
resumeTopActivityUncheckedLocked-->resumeTopActivityInnerLocked{
- ActivityRecord next = topRunningActivityLocked
- mResumedActivity == next,executeAppTransition//已经为resumed状态
- mStackSupervisor.allPausedActivitiesComplete()//是否正在暂停
- mResumedActivity != null,startPausingLocked//需要暂停前一个ResumedActivity
 //隐藏前一个应用窗口
- prev != null{
	- activity.finishing,mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_CLOSE/TRANSIT_TASK_CLOSE) //设置动画
	- !activity.finishing,mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN/TRANSIT_TASK_OPEN_BEHIND/TRANSIT_TASK_OPEN)
  }else{
  	- mWindowManager.prepareAppTransition(TRANSIT_NONE/TRANSIT_ACTIVITY_OPEN)//设置动画
  }
 //进程启动.显示,设置状态当前resumedAcivity
- next.setVisibility(true)
- next.completeResumeLocked()
 //进程没有启动
- mStackSupervisor.startSpecificActivityLocked
}@ActivityStack.java



//显示
ensureActivitiesVisibleLocked{
 //遍历display
- int displayNdx = mActivityDisplays.size()
 //遍历stack
- stacks = mActivityDisplays.valueAt(displayNdx).mStacks
- ActivityStack stack = stacks.get(stackNdx)
- stack.ensureActivitiesVisibleLocked
}@ActivityStackSupervisor.java-->
ensureActivitiesVisibleLocked(ActivityRecord starting,int configChanges,boolean preserveWindows){
- 遍历task,TaskRecord task = tmpTaskHistory.get(taskNdx)
 //遍历ActivityRecord,
- ArrayList<ActivityRecord> activities = task.mActivities
- ActivityRecord r = activities.get(activityNdx)
- 显示reallyVisible,{
	- r.ensureActivityConfigurationLocked
	- r.makeVisibleIfNeeded
	}
- 隐藏!reallyVisible{
	- makeInvisible
	}
}@ActivityStack.java


//force hide
pinnedStack.mForceHidden = true

frameworks/base/core/java/android/app/Activity.java
frameworks/base/core/java/android/app/Instrumentation.java
frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/core/java/com/android/server/am/ActivityStarter.java
frameworks/base/services/core/java/com/android/server/am/ActivityStackSupervisor.java
