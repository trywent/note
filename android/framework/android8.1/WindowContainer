/**********************
        RootWindowContainer extends WindowContainer
	- DiplayContent extends WindowContainer
	  - TaskStack extends WindowContainer
	    - Task extends WindowContainer
  	      - AppWindowToken extends WindoToken extends WindowContainer
		- windowState entends WindowContainer

窗口宽高比默认改为0.DEFAULT_PRE_O_MAX_ASPECT_RATIO=1.86@PackageParser.java

*/
 
WindowContainer{
- WindowList<E> mChildren = new WindowList<E>() //child
- mOverrideConfiguration          //当前容器的配置,每个容器的大小可能不一样
- mFullConfiguration
- mMergedOverrideConfiguration
- addChild(child){
	- mChildren.add
	- child.setParent-->onParentSet
	}
- onConfigurationChanged{
	- mFullConfiguration.setTo
	- 遍历child,更新child.onConfigurationChanged
	}
- onOverrideConfigurationChanged {//更新配置,包括所有child都会更新
	- onConfigurationChanged
	- onMergedOverrideConfigurationChanged	
	}
- onMergedOverrideConfigurationChanged{
	- mMergedOverrideConfiguration
	- 遍历child,更新child.mMergedOverrideConfiguration
	}
}@WindowContainer.java

/*
 RootWindowContainer
 
 创建DisplayContent并加入RootWindowContainer
*/
new RootWindowContainer(this)@WindowManagerService.java-->
RootWindowContainer(WindowManagerService service) {
- mService = service;
- mLayersController = new WindowLayersController(mService);
- mWallpaperController = new WallpaperController(mService);
}

getDisplayContentOrCreate-->
createDisplayContent(){
- DisplayContent dc = new DisplayContent(display, mService, mLayersController,mWallpaperController)
  //设置displayInfo..读取保存的屏幕信息。将当前屏幕信息设置到LogicDisplay
- DisplayInfo displayInfo = dc.getDisplayInfo()
- mService.mDisplaySettings.getOverscanLocked(displayInfo.name, displayInfo.uniqueId, rect)
- isplayInfo.overscanLeft = rect.left
- mService.mDisplayManagerInternal.setDisplayInfoOverrideFromWindowManager(displayId, displayInfo)
}



frameworks/base/services/core/java/com/android/server/wm/RootWindowContainer.java
====== 1
/**********************
  displayContent初始化.加入到RootWindowContainer中
  displayContent包含4种Container
	mAboveAppWindowsContainers
	mTaskStackContainers //所有应用窗口容器
	mBelowAppWindowsContainers
	mImeWindowsContainers
*/

DisplayContent(Display display, WindowManagerService service,WindowLayersController layersController){
- mDisplay = display
- display.getDisplayInfo(mDisplayInfo)
  //
- mLayersController = layersController //窗口layer设置
- mDividerControllerLocked = new DockedStackDividerController
- mPinnedStackControllerLocked = new PinnedStackController
- mDimLayerController = new DimLayerController
- super.addChild(mAboveAppWindowsContainers)
- super.addChild(mTaskStackContainers) //应用窗口
- super.addChild(mBelowAppWindowsContainers)
- super.addChild(mImeWindowsContainers)
- mService.mRoot.addChild(this, null) //加入到mRoot
}@DisplayContent.java

//初始化屏幕信息
initializeDisplayBaseInfo() {
- updateBaseDisplayMetrics(mDisplayInfo.logicalWidth, mDisplayInfo.logicalHeight,mDisplayInfo.logicalDensityDpi);
- mInitialDisplayWidth = mDisplayInfo.logicalWidth;
- mInitialDisplayHeight = mDisplayInfo.logicalHeight;
}

updateDisplayAndOrientation(int uiMode){

}

//保存windowToken(对应ActivityRecord)
onDisplayChanged(dc)-->dc.reParentWindowToken@WindowToken.java-->reParentWindowToken-->
addWindowToken(IBinder binder, WindowToken token)-->mTokenMap.put(binder, token)@DisplayContent.java

/*更新displayInfo*/
updateDisplayInfo@DisplayContent.java-->updateDisplayInfo(bounds){
- mChildren.get(taskNdx).updateDisplayInfo{

	}@Task.java
- setBounds
}@TaskStack.java

//遍历窗口,执行回调callback
forAllWindows@@DisplayContent.java-->....-->
forAllWindows{
- child.forAllWindows(callback,traverseTopToBottom){
	//没有子窗口
	- applyInOrderWithImeWindows(callback)-->callback.apply(this)
	//有子窗口
	- forAllWindowTopToBottom(callback)-->callback.apply//从上至下
	- forAllWindowBottomToTop //从下至上
	}@WindowState.java
}@AppWindowToken.java


----------- 1
//更新窗口
applySurfaceChangesTransaction(boolean recoveringMemory){
- mWallpaperController.adjustWallpaperWindows(this)
  //有待处理FINISH_LAYOUT_REDO_CONFIG
- mService.updateOrientationFromAppTokensLocked
  //有待处理FINISH_LAYOUT_REDO_LAYOUT
- setLayoutNeeded()-->mLayoutNeeded = true
- performLayout
- mService.mPolicy.beginPostLayoutPolicyLw
- forAllWindows(mApplyPostLayoutPolicy, true)
- mService.mPolicy.finishPostLayoutPolicyLw()
  //布局完成,更新窗口大小
- forAllWindows(mApplySurfaceChangesTransaction)
}@DisplayContent.java

/* 更新窗口大小  */
performLayout(boolean initial, boolean updateInputWindows){
- mService.mPolicy.beginLayoutLw(isDefaultDisplay, dw, dh, mRotation)
- mService.mPolicy.getContentRectLw(mContentRect)
- forAllWindows(mPerformLayout, true)-->mPerformLayout(windowState w){
	- w.prelayout()
	- mService.mPolicy.layoutWindowLw-->win.computeFrameLw@PhoneWindowManager.java// 计算窗口大小
	}

- forAllWindows(mPerformLayoutAttached, true )-->mPerformLayoutAttached(WindowState w){ //layout关联窗口
	- 
	}
  //更新input
- mService.mInputMonitor.layoutInputConsumers(dw, dh)
- mService.mInputMonitor.updateInputWindowsLw
- mService.mPolicy.finishLayoutLw
}@DisplayContent.java

//windowState更新窗口大小
mApplySurfaceChangesTransaction(WindowState){
- 
- w.updateResizingWindowIfNeeded()
}@DisplayContent.java

//设置窗口layer
assignWindowLayers-->mLayersController.assignWindowLayers(this)@DisplayContent.java-->
assignWindowLayers{
- dc.forAllWindows(mAssignWindowLayersConsumer)-->mAssignWindowLayersConsumer{ //设置所有窗口layer
	- mCurBaseLayer = mCurLayer = w.mBaseLayer //mBaseLayer=policy.getWindowLayerLw
	- assignAnimLayer(WindowState w, int layer){
		- w.mLayer = layer	
		- w.mWinAnimator.mAnimLayer = w.getAnimLayerAdjustment()
                	+ w.getSpecialWindowAnimLayerAdjustment //mLayer + specialAdjustment
		}
	- 
	}
- adjustSpecialWindows
}@WindowLayaersController.java

//更新配置
performDisplayOverrideConfigUpdate@ActivityManagerService.java-->setNewDisplayOverrideConfiguration@WindowManagerService.java
-->setDisplayOverrideConfigurationIfNeeded@RootWindowContainer.java-->displayContent.onOverrideConfigurationChanged


====== 2
/*
  TaskStack
*/
StackWindowController(int stackId, StackWindowListener listener, boolean onTop, Rect outBounds)-->
StackWindowController(int stackId, StackWindowListener listener, boolean onTop, Rect outBounds, WindowManagerService service)
{
- DisplayContent dc = mRoot.getDisplayContent(displayId) //mRoot为WindowManagerService
- TaskStack stack = dc.addStackToDisplay(stackId){
	- TaskStack stack = getStackById(stackId)
	- stack = new TaskStack(mService, stackId)
	- mTaskStackContainers.addStackToDisplay(stack){//加入到TaskStackContainers(所有应用窗口的归宿)
		- addChild(stack)
		- stack.onDisplayChanged(DisplayContent.this){ //通知displayContent变化...通知到所有child
			- if (mStackId == DOCKED_STACK_ID){//设置docked栈大小
				- getStackDockedModeBounds(mTmpRect, bounds, mStackId, mTmpRect2)
				}
			- if (mStackId == PINNED_STACK_ID){//设置pip栈大小
				- getAnimationOrCurrentBounds(mTmpRect2)
				}
			- updateDisplayInfo(bounds)
			}
		}
	}@DisplayContent.java
- stack.setController(this) //设置controler ,container
- getRawBounds(outBounds){
	- 从mContainer 获取窗口大小 //从TaskStack获取
	}
}@StackWindowController.java

//调整窗口大小,
resize(Rect bounds, SparseArray<Configuration> configs)-->mContainer.setBounds@StackWindowController.java-->
setBounds(Rect stackBounds, SparseArray<Configuration> configs){
- setBounds(stackBounds)
  //遍历task设置大小
- task.resizeLocked
}@TaskStack.java

//ActivityManager中TaskRecord,更新configuration
computeOverrideConfiguration@TaskRecord.java-->
adjustConfigurationForBounds(Rect bounds,Configuration config){
- 
- config.screenWidthDp = width
- config.screenHeightDp = height
- config.smallestScreenWidthDp = getSmallestWidthForTaskBounds()
}@StackWindowController.java



====== 3
/*
  Task
*/
TaskWindowContainerController(int taskId, TaskWindowContainerListener listener,StackWindowController stackController,  Rect bounds){
- TaskStack stack = stackController.mContainer
- Task task = createTask-->new Task(this,bounds){
	- setController(controller)//设置controler ,container
	- setBounds
	}@Task.java
- stack.addTask(task)-->addChild
}@TaskWindowContainerController.java

//管理栈大小,栈动画
TaskStack extends WindowContainer<Task> implements DimLayer.DimLayerUser,
        BoundsAnimationTarget{
  //栈大小变化动画
- onAnimationStart
- onAnimationEnd
- setPinnedStackSize
}

//当加入到Stack时被调用,默认大小
onParentSet{
- updateDisplayInfo(getDisplayContent()){
	- setBounds //若屏幕旋转后需要更新大小
	}
- forceWindowsScaleable
}@Task.java

//大小
resize-->mContainer.resizeLocked@TaskWindowContainerController.java-->
resizeLocked(Rect bounds, Configuration overrideConfig){
- int boundsChanged = setBounds(Rect bounds, Configuration overrideConfig){
	- boundsChange//位置大小是否发生变化
	- mBounds.set(bounds)
	- onOverrideConfigurationChanged(overrideConfig) //WindowContainer更新配置
	}
  //遍历更新child,
- boundsChanged发生变化,onResize-->wc.onResize()
}@Task.java

getBounds{
- if(useCurrentBounds()){//当条件满足:不能调整task大小的栈(能被docked调整task的为home,fullscreen)/Dodked栈存在
	- mBounds
	}
- mStack.getDisplayContent().getLogicalDisplayRect(out)
}@Task.java


====== 4 
/*
 AppWindowToken extends WindowToken
 ActivityManager端创建windowToken加入到displayContent.mTokenMap中,会传入ActivityRocord.appToken.
 应用进程加入实际窗口时addWindow会传入同一个appToken...
 
 这样应用WindowState和关联AppWindowToken起来.可以由服务管理
 
*/

AppWindowContainerController(token/*ActivityRecord.appToken*/){
- mToken = token
- AppWindowToken atoken = createAppWindow(token,task.getDisplayContent())-->new AppWindowToken{
	- super()-->WindowToken(WindowManagerService service, IBinder _token){
		- token = _token
		- onDisplayChanged(dc)-->dc.reParentWindowToken(this) //加入到DisplayContent
		}@WindowToken.java
	- this{
		- mInputApplicationHandle = new InputApplicationHandle(this)
		- mAppAnimator = new AppWindowAnimator(this, service)
		- onOverrideConfigurationChanged
		- mBounds.set(bounds)
		}
	- setController(controller)//设置controler ,container
	}@AppWindowToken.java
- task.addChild(atoken) //加入到task
}@AppWindowContainerController.java


//加入窗口WindowState
addWindow(Session session,IWindow Client,WindowManager.LayoutParams attrs){
- WindowToken token = displayContent.getWindowToken(attrs.token)
- AppWindowToken atoken = token.asAppWindowToken()
- WindowState win = new WindowState(this, session, client, token){
	- mToken = token
	}
- win.mToken.addWindow(win) //将WindowState加入AppWindowToken
}@WindowManagerService.java



setBounds-->updateAdjustedBounds
onOverrideConfigurationChanged-->onConfigurationChanged@WindowContainer.java

/* AppWindow动画


*/

//设置动画
setAnimation

stepAnimationLocked(long currentTime) {
- 

}

frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java
frameworks/base/services/core/java/com/android/server/wm/WindowContainer.java
frameworks/base/services/core/java/com/android/server/wm/WindowContainerController.java
frameworks/base/services/core/java/com/android/server/wm/Task.java
frameworks/base/services/core/java/com/android/server/am/ConfigurationContainer.java
frameworks/base/services/core/java/com/android/server/wm/WindowState.java
frameworks/base/services/core/java/com/android/server/wm/AppWindowToken.java
frameworks/base/services/core/java/com/android/server/wm/AppWindowAnimator.java
