/******************************
 WindowStateAnimator

*/
WindowState-->WindowStateAnimator(WindowState win){//windowState中创建
- WindowManagerService mService = win.mService
- mWin = win
}@WindowStateAnimator.java


//创建 surfaceControl
relayoutWindow-->
createSurfaceControl(Surface outSurface, int result, WindowState win,WindowStateAnimator winAnimator)@WindowManagerService.java-->
createSurfaceLocked(windowType){
  //surfacecontroller
- mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession,width, height){
	- mSurfaceW = w
	- mSurfaceH = h
	- mSurfaceControl = new SurfaceControlWithBackground{
		- super-->new SurfaceControl
		- mBackgroundControl = new SurfaceControl(s, "Background for")
		}
	}
- w.setHasSurface(true)
 //surface位置
- mService.openSurfaceTransaction()
- mSurfaceController.setPositionInTransaction
- mSurfaceController.setLayerStackInTransaction
- mSurfaceController.setLayer(mAnimLayer)
- mService.closeSurfaceTransaction()
}@WindowStateAnimator.java

animate@WindowAnimator.java-->prepareWindowSurfaces@DisplayContent.java-->
prepareSurfaceLocked{
- computeShownFrameLocked
- setSurfaceBoundariesLocked
}@WindowStateAnimator.java

/*
 surfaceInsets 会影响实际窗口大小
*/

setSurfaceBoundariesLocked{
 //设置mTmpSize原点,再设置大小
- mTmpSize.set(w.mShownPosition.x, w.mShownPosition.y, 0, 0)
- calculateSurfaceBounds(attr){
	- mTmpSize.right,mTmpSize.bottom
	- 根据surfaceInsets调整mTmpSize
	}
- mSurfaceController.setSizeInTransaction //设置大小
  //是否裁剪
- calculateCrop(mTmpClipRect){
	- w.inPinnedWorkspace(),pinstack中返回
	  //根据surfaceinset调整大小
	- adjustCropToStackBounds{
		- Rect surfaceInsets = w.getAttrs().surfaceInsets
		}
	}
- calculateFinalCrop(mTmpFinalClipRect){
	- 
	}
- isForceScaled(){
	- mSurfaceController.setPositionInTransaction //设置位置
	}
}@WindowStateAnimator.java

calculateSurfaceBounds
//销毁
destroySurfaces-->win.destroySurface@AppWindowToken.java-->destroySurface@WindowState.java-->
destroyPreservedSurfaceLocked-->destroyDeferredSurfaceLocked

destroySurfaceLocked{
- if(mSurfaceDestroyDeferred){
	- mPendingDestroySurface.destroyInTransaction
  }else{
	- destroySurface-->mSurfaceController.destroyInTransaction()
	}
- mWin.setHasSurface(false)
}@WindowStateAnimator.java

 

/*
  动画
*/
//设置动画
setAnimation(Animation anim, long startTime, int stackClip){
- mAnimation = anim
- mAnimation.restrictDuration(WindowManagerService.MAX_ANIMATION_DURATION)
- mAnimation.scaleCurrentDuration(mService.getWindowAnimationScaleLocked())
  //
- mTransformation.clear()
- mTransformation.setAlpha(mLastHidden ? 0 : 1)
}@WindowStateAnimator.java

applyAnimationLocked(int transit, boolean isEntrance) {}

//动画执行。WindowAnimator收到vsync执行动画
animate-->dc.updateWindowsForAnimator@WindowAnimator.java-->updateWindowsForAnimator(WindowAnimator animator)
-->forAllWindows(mUpdateWindowsForAnimator, true)-->winAnimator.stepAnimationLocked@DisplayContent.java-->
stepAnimationLocked(long currentTime){
- if (!mLocalAnimating) {				//第一次初始化animation
	- mAnimation.initialize
	- mAnimation.setStartTime
	- mLocalAnimating = true
	- mAnimating = true
	}
- stepAnimation(currentTime){
	- currentTime = getAnimationFrameTime(mAnimation, currentTime)
	- mTransformation.clear()
	- boolean more = mAnimation.getTransformation(currentTime, mTransformation)
	}
- if(stepAnimation)return true 				//动画没有执行完成
 //动画执行完成
- mAnimating = false
- mAnimation = null
- mTransformation.clear()
- mWin.onExitAnimationDone()
- mAnimator.setPendingLayoutChanges
- mWin.mAppToken.updateReportedVisibilityLocked()	//通知appToken-->ActivityRecord
}@WindowStateAnimator.java


//将animation结果作用到窗口
animate-->dc.prepareWindowSurfaces-->forAllWindows(mPrepareWindowSurfaces, false)@WindowAnimator.java-->
prepareSurfaceLocked(final boolean recoveringMemory){
- 
- computeShownFrameLocked
- setSurfaceBoundariesLocked(recoveringMemory)
}@WindowStateAnimator.java

computeShownFrameLocked() {
- 
- 
}@WindowStateAnimator.java

frameworks/base/services/core/java/com/android/server/wm/WindowStateAnimator.java
frameworks/base/services/core/java/com/android/server/wm/WindowSurfaceController.java
