/**********************
 窗口加入删除,布局

*/
WindowManagerService{
- mRoot = new RootWindowContainer(this)
- mPolicy = policy
- mFxSession = new SurfaceSession()

- mAppTransition = new AppTransition(context, this)
- AnimationHandler animationHandler = new AnimationHandler()
- animationHandler.setProvider(new SfVsyncFrameCallbackProvider())
- mBoundsAnimationController = new BoundsAnimationController(context, mAppTransition,animationHandler)
- WindowAnimator mAnimator = new WindowAnimator(this)

}@WindowManagerService.java


onDisplayAdded(displayId){
- display = mDisplayManager.getDisplay(displayId)
- createDisplayContentLocked-->mRoot.getDisplayContentOrCreate-->
	createDisplayContent{
	- dc = new DisplayContent
	- displayInfo = dc.getDisplayInfo() //初始化displayinfo
	- dc.mTapDetector = new TaskTapPointerEventListener //触摸监听
	- mService.registerPointerEventListener(dc.mTapDetector)
	}@RootWindowContainer.java
- displayReady
}@WindowManagerService.java


//创建session
getWindowSession@WindowManagerGlobal.java-->openSession-->new Session(IInputMethodClient,IInputContext)
@WindowManagerServivce.java

//window
addWindow(Session,IWindow client,WindowManager.LayoutParams attrs){
- WindowToken token = displayContent.getWindowToken(attrs.token) //获取对应ActivityRecord的WindowToken(本质一个AppWindowToken)
- AppWindowToken atoken = token.asAppWindowToken() //FIRST_APPLICATION_WINDOW -LAST_APPLICATION_WINDOW 应用窗口
- WindowState win = new WindowState(this, session, client, token,attrs){
	- mSession = s
	- mClient = c
	- mToken = token
	}
- win.attach()
- mWindowMap.put(client.asBinder(), win)
- win.mToken.addWindow(win) //将windowState加入到AppWindowToken
- mPolicy.getInsetHintLw(outOutsets) //获取初始窗口大小
}@WindowManagerService.java

relayoutWindow(Session session, IWindow client,WindowManager.LayoutParams attrs){
- win.relayoutVisibleWindow
- createSurfaceControl(Surface outSurface,WindowState win
}
//创建surface
relayoutWindow-->createSurfaceControl(Surface outSurface,WindowState win,WindowStateAnimator winAnimator){
- WindowSurfaceController surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type) //创建
- surfaceController.getSurface(outSurface)
}@WindowManagerService.java

=====================
/*
应用设置方位
*/
setRequestedOrientation@ActivityManagerService.java-->setRequestedOrientation{
- displayConfig = mStackSupervisor.getDisplayOverrideConfiguration
- mWindowContainerController.setOrientation(requestedOrientation){ //设置方位
	- mContainer.setOrientation(requestedOrientation) //保存要设置的方位
	- mService.updateOrientationFromAppTokens(displayConfig,displayId)
	}@AppWindowContainerController.java
- service.updateDisplayOverrideConfigurationLocked
}@ActivityRecord.java


updateOrientationFromAppTokens-->updateOrientationFromAppTokensLocked(currentConfig){
- 计算方位是否改变,updateOrientationFromAppTokensLocked(false,displayId)
- 若改变,computeNewConfigurationLocked
- 若没改变,且currentConfig!=null{
	- displayContent.computeScreenConfiguration
	}
}

//更新窗口方位.先根据非应用窗口计算,然后再计算应用窗口
updateOrientationFromAppTokensLocked{
- DisplayContent dc = mRoot.getDisplayContent(displayId)
- req = dc.getOrientation{
	- 屏幕冻结,返回mLastWindowForcedOrientation
	- 返回mAboveAppWindowsContainers.getOrientation() //非应用窗口
	- 返回 mTaskStackContainers.getOrientation //应用窗口
	}
- req!=dc.getLastOrientation(){//方位发生变化
	- dc.setLastOrientation(req) //更新最后一次方位
	- mPolicy.setCurrentOrientationLw(req){
		- mCurrentAppOrientation =req //设置app方位	
		- updateOrientationListenerLp
		}@PhoneWindowManager.java
	- dc.updateRotationUnchecked //更新屏幕..最终调用位置
	}
}@WindowManagerService.java



//传感器更新方位
updateRotation(false)@PhoneWindowManager-->updateRotation-->
updateRotationUnchecked{
- displayContent = getDefaultDisplayContentLocked
- displayContent.updateRotationUnchecked(false)
- sendNewConfiguration(displayId)//方位变化更新配置
}@WindowManagerService.java

//打开或关闭传感器listener
updateOrientationListenerLp{
- !mOrientationListener.canDetectOrientation() //传感器无效返回
- needSensorRunningLp{
	- mOrientationListener.enable	
	}
- mOrientationListener.disable
}@PhoneWindowManager.java


rotationForOrientationLw{//从传感器获取方位
- mOrientationListener.getProposedRotation() //获取传感器方位
- preferredRotation
}

//最终调用位置,更新方位
updateRotationUnchecked{
-
- mService.mPolicy.rotationForOrientationLw(lastOrientation, oldRotation) //从传感器获取方位
- updateDisplayAndOrientation{//更新displayManager
	- 初始化mDisplayInfo
	- mService.mDisplayManagerInternal.setDisplayInfoOverrideFromWindowManager(mDisplayInfo)
	}
- mService.mDisplayManagerInternal.performTraversal(getPendingTransaction()) //DisplayManager设置display
- scheduleAnimation
}@DisplayContent.java


======================
//应用窗口大小

relayoutWindow(Session session, IWindow client,int requestedWidth,Rect outFrame,Surface outSurface){
- WindowState win = windowForClientLocked-->mWindowMap.get(client) //获取对应窗口
- mPolicy.adjustWindowParamsLw(attrs) //调整属性
- createSurfaceControl(outSurface)//surface
- configChanged = updateOrientationFromAppTokensLocked //更新方位
- 
}@WindowManagerService.java


=====================
/* 冻结画面
  设置旋转动画到WindowAnimator
*/
startFreezingDisplayLocked(boolean inTransaction, int exitAnim, int enterAnim,int displayId){
- mScreenFrozenLock.acquire() //wakeLock
- mDisplayFrozen = true
- mFrozenDisplayId = displayContent.getDisplayId()
- mAppTransition.freeze(){

	}
- mExitAnimId = exitAnim,mEnterAnimId = enterAnim
  //先停止WindowAnimator中已有动画
- ScreenRotationAnimation screenRotationAnimation = mAnimator.getScreenRotationAnimationLocked(mFrozenDisplayId)
- screenRotationAnimation.kill()
- screenRotationAnimation = new ScreenRotationAnimation
- mAnimator.setScreenRotationAnimationLocked(mFrozenDisplayId,screenRotationAnimation) //设置到WindowAnimator
}@WindowManangerService.java


stopFreezingDisplayLocked{
- DisplayContent displayContent = mRoot.getDisplayContent(mFrozenDisplayId)
- displayId = mFrozenDisplayId
- mDisplayFrozen = false
- mAnimator.setScreenRotationAnimationLocked(displayId, null)//设置旋转动画为空
  //冻结结束,更新画面
- boolean configChanged = updateOrientationFromAppTokensLocked
- mH.obtainMessage(H.SEND_NEW_CONFIGURATION)
}

/*
 启动结束
*/
//动画结束


//打开屏幕
performSurfacePlacement@RootWindowContainer.java-->enableScreenIfNeeded-->enableScreenIfNeededLocked-->
performEnableScreen{
  //是否可以结束动画，keyguard是否绘制
- mPolicy.canDismissBootAnimation(){
	- mKeyguardDrawComplete	
	}@PhoneWindowMananger.java
  //是否有显示窗口
- getDefaultDisplayContentLocked().checkWaitingForWindows(){
	- 
	}@DisplayContent.java
  //结束动画
- SystemProperties.set("service.bootanim.exit", "1")
  //检查动画是否结束，没有则继续等待
- checkBootAnimationCompleteLocked

  //启动完成
- mActivityManager.bootAnimationComplete()
}@WindowManagerService.java


frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/core/java/com/android/server/am/ActivityRecord.java
frameworks/base/services/core/java/com/android/server/wm/AppWindowContainerController.java
frameworks/base/services/core/java/com/android/server/wm/DisplayContent.java
frameworks/base/services/core/java/com/android/server/wm/RootWindowContainer.java
