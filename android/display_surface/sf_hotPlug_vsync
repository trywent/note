/**************
  display事件
 
  HAL --> HWC --> SurfaceFlinger --> DispSync --> EventThread --> DisplayEventReceiver

*/
//设置display初始模式
SurfaceFlinger::onInitializeDisplays-->setPowerModeInternal(getDisplayDevice(d.token), HWC_POWER_MODE_NORMAL,false)
-->setPowerModeInternal(const sp<DisplayDevice>& hw,int mode, bool stateLockHeld){
- int32_t type = hw->getDisplayType()
- int currentMode = hw->getPowerMode()
- hw->setPowerMode(mode)
  //设置display模式
- if (currentMode == HWC_POWER_MODE_OFF) {	//当前是关闭
	- getHwComposer().setPowerMode(type, mode)
	- mEventThread->onScreenAcquired()
	- resyncToHardwareVsync(true)
	- repaintEverythingLocked
  }else if (mode == HWC_POWER_MODE_OFF) {	//关闭display
  	- disableHardwareVsync(true)
	- mEventThread->onScreenReleased()
	- getHwComposer().setPowerMode(type, mode)
  }else if (mode == HWC_POWER_MODE_DOZE ||mode == HWC_POWER_MODE_NORMAL){
	- getHwComposer().setPowerMode(type, mode)
	- mEventThread->onScreenAcquired()
	- resyncToHardwareVsync(true)
  }else if (mode == HWC_POWER_MODE_DOZE_SUSPEND){
	  //关闭vsync
	- disableHardwareVsync(true)
	- getHwComposer().setPowerMode(type, mode)
  }else{
	- getHwComposer().setPowerMode(type, mode)
  }
}@SurfaceFlinger.cpp

//请求vsync
requestNextVsync-->mFlinger.resyncWithRateLimit()@EventThread.cpp-->- resyncToHardwareVsync(false)-->
resyncToHardwareVsync(bool makeAvailable){ //两个请求之间的间隔要大于500ms
- if (makeAvailable) {
        - mHWVsyncAvailable = true
    } else if (!mHWVsyncAvailable) {
	- return
    }
 //获取配置信息
- auto& activeConfig = mHwc->getActiveConfig(HWC_DISPLAY_PRIMARY)
- nsecs_t period = activeConfig->getVsyncPeriod()
- mPrimaryDispSync.setPeriod(period)
- if(!mPrimaryHWVsyncEnabled){
	- mPrimaryDispSync.beginResync()
	- mEventControlThread->setVsyncEnabled(true)
	- mPrimaryHWVsyncEnabled = true
	}
}@SurfaceFlinger.cpp


//从hal收到事件。onVsync，onHotplug
ComposerCallbackBridge::onVsync(Hwc2::Display display, int64_t timestamp)/*hal层回调*/-->
mCallback->onVsyncReceived(mSequenceId, display, timestamp)@HWC2.cpp-->
SurfaceFlinger::onVsyncReceived(int32_t sequenceId,hwc2_display_t displayId, int64_t timestamp){
- mHwc->onVsync(displayId, timestamp, &type)-->HWComposer::onVsync@HWComposer.cpp
- bool needsHwVsync = mPrimaryDispSync.addResyncSample(timestamp)
- if (needsHwVsync) {
	- enableHardwareVsync()
    } else {
        - disableHardwareVsync(false)
    }
}@SurfaceFlinger.cpp


/**************
 DispSync开关同步。DispSyncThread计算并发出vsync事件提供给DispSyncSource

 DispSync(DispSyncThread) --> DispSyncSource --> EventThread
 
*/
//创建DispSync,并初始化
SurfaceFlinger{
- mPrimaryDispSync("PrimaryDispSync")
- mPrimaryDispSync.init(hasSyncFramework, dispSyncPresentTimeOffset) 
}@SurfaceFlinger.cpp

DispSync("PrimaryDispSync"){
- mName("PrimaryDispSync")
- mThread(new DispSyncThread(name))-->DispSyncThread{
	- mName(name)
	- mPeriod(0)
	}
}@DispSync.cpp

DispSync::init(bool hasSyncFramework, int64_t dispSyncPresentTimeOffset){
  //开始执行threadLoop
- mThread->run("DispSync", PRIORITY_URGENT_DISPLAY + PRIORITY_MORE_FAVORABLE)-->DispSyncThread::threadLoop
- sched_setscheduler(mThread->getTid(), SCHED_FIFO, &param)
- reset()
- beginResync()
}@DispSync.cpp


//
DispSync::beginResync() {
- mModelUpdated = false
- mNumResyncSamples = 0
}

//收到一个vsync事件时间戳
//一个循环数组中。mFirstResyncSample永远指向最开始的一个数据（时间递增，非乱序）
//mNumResyncSamples事件个数，可被复位为0
SurfaceFlinger::onVsyncReceived(int32_t sequenceId,hwc2_display_t displayId, int64_t timestamp-->
DispSync::addResyncSample(nsecs_t timestamp) {
- size_t idx = (mFirstResyncSample + mNumResyncSamples) % MAX_RESYNC_SAMPLES
- mResyncSamples[idx] = timestamp			//记录vsync事件发生的时间戳
- if (mNumResyncSamples == 0) {				//复位后第一次获取vsync时间值
	- mPhase = 0
	- mReferenceTime = timestamp			//记录复位后第一个vsync的时间，作为基准值
	- mThread->updateModel(mPeriod, mPhase, mReferenceTime)
	}
- if (mNumResyncSamples < MAX_RESYNC_SAMPLES) {
        mNumResyncSamples++
    } else {
        mFirstResyncSample = (mFirstResyncSample + 1) % MAX_RESYNC_SAMPLES
    }
- updateModelLocked
}@DispSync.cpp

//设置period
DispSync::setPeriod(nsecs_t period) {
- mPeriod = period
- mPhase = 0
- mReferenceTime
- mThread->updateModel(mPeriod, mPhase, mReferenceTime)
}@DispSync.cpp

DispSync::updateModelLocked() {
  //有6个vsync就可以计算脉冲的平均时间间隔。去除3个值计算平均值。第一个值，一个最小值，一个最大值
- mPeriod = durationSum / (mNumResyncSamples - 3)
  //每个vsync的间隔时间与mperiod平均差值
- mPhase = nsecs_t(atan2(sampleAvgY, sampleAvgX) / scale)
  //设置跳过帧数后的周期值
- mPeriod += mPeriod * mRefreshSkipCount		
- mThread->updateModel(mPeriod, mPhase, mReferenceTime)	//设置周期，偏移，参考值
- mModelUpdated = true
}

/*
 DispSyncThread 根据hal上报的Vsync时间，计算vsync周期。定时产生事件并发送给client

*/
DispSync-->DispSyncThread{
- mName(name)
- mPeriod(0)
}DispSync.cpp

//更新参考时间
DispSync::updateModel(nsecs_t period, nsecs_t phase, nsecs_t referenceTime) {
- mPeriod = period
- mPhase = phase
- mReferenceTime = referenceTime
}@DispSync.cpp

//加入listener
DispSyncSource::setVSyncEnabled(bool enable)-->mDispSync->addEventListener(mName, mPhaseOffset,(this))@SurfaceFlinger.cpp-->
DispSyncThread::addEventListener(const char* name, nsecs_t phase, const sp<DispSync::Callback>& callback){
- EventListener listener
- listener.mPhase = phase
- listener.mCallback = callback
- listener.mLastEventTime = systemTime() - mPeriod / 2 + mPhase -mWakeupLatency
- mEventListeners.push(listener)
}@DispSync.cpp

//等待事件,分发给listener
DispSyncThread::threadLoop{
  //获取最近的要触发的事件
- nsecs_t now = systemTime(SYSTEM_TIME_MONOTONIC)
- nsecs_t targetTime = computeNextEventTimeLocked(now){
	- for (size_t i = 0; i < mEventListeners.size(); i++) {
		- nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i],now)
		- if (t < nextEventTime) nextEventTime = t
		}
	}
  //等待
- mCond.waitRelative(mMutex, targetTime - now)
  //判断被触发的监听器，准备回调
- now = systemTime(SYSTEM_TIME_MONOTONIC)
- Vector<CallbackInvocation> callbackInvocations = gatherCallbackInvocationsLocked(now){
	  //获取当前时间，
	- nsecs_t onePeriodAgo = now - mPeriod
	- for (size_t i = 0; i < mEventListeners.size(); i++) {
		- nsecs_t t = computeListenerNextEventTimeLocked(mEventListeners[i],onePeriodAgo)
		- if (t < now) {
			- CallbackInvocation ci
                	- ci.mCallback = mEventListeners[i].mCallback
			- callbackInvocations.push(ci)
			}
		}
	- return callbackInvocations
	}
  //触发回调,回调surfaceFlinger中加入的listener
- if (callbackInvocations.size() > 0){
	- fireCallbackInvocations(callbackInvocations)-->callbacks[i].mCallback->onDispSyncEvent(callbacks[i].mEventTime-->
 		DispSyncSource::onDispSyncEvent@SurfaceFlinger.cpp
	}
}@DispSync.pp

//获取listener(获取脉冲事件者)要触发的时间
computeListenerNextEventTimeLocked(const EventListener& listener,nsecs_t baseTime/*单调递增的系统启动时间*/) {
- baseTime -= mReferenceTime				//从第一个采样到baseTime经过的时间
- nsecs_t phase = mPhase + listener.mPhase		//
- baseTime -= phase
- if (baseTime < 0) baseTime = -mPeriod
  //获得正确basetime(整数脉冲的倍数)后，计算下一个脉冲时间
- nsecs_t numPeriods = baseTime / mPeriod		//当前时间有多少个脉冲
- nsecs_t t = (numPeriods + 1) * mPeriod + phase	//下一个脉冲的时间+偏移
- t += mReferenceTime
- t -= mWakeupLatency					//等待唤醒所需的时间
- return t						//计算出下一个脉冲的时间
}@DispSysnc.cpp



/**************
  DispSyncSource public VSyncSource, private DispSync::Callback
   操作vsync开关
   接收DispSync事件
   转发DispSync事件给EventThread
*/
//创建DispSyncSource
SurfaceFlinger::init{
- sp<VSyncSource> sfVsyncSrc = new DispSyncSource(&mPrimaryDispSync,sfVsyncPhaseOffsetNs, true, "sf"){
	- mDispSync(mPrimaryDispSync)
	}
- mSFEventThread = new EventThread(sfVsyncSrc, *this, true)
- mEventQueue.setEventThread(mSFEventThread)
}@SurfaceFlinger.cpp

//加入listener接收DispSync的事件
enableVSyncLocked@EventThread.cpp-->
DispSyncSource::setVSyncEnabled(bool enable){
- if(enable){
  	- mDispSync->addEventListener(mName, mPhaseOffset, static_cast<DispSync::Callback*>(this))
  }else{
	- mDispSync->removeEventListener(static_cast<DispSync::Callback*>(this))
	}
}@SurfaceFlinger.cpp

//加入回调EventThread
enableVSyncLocked-->mVSyncSource->setCallback(static_cast<VSyncSource::Callback*>(this))@EventThread.cpp-->
DispSyncSource::setCallback(const sp<VSyncSource::Callback>& callback)-->mCallback = callback@SurfaceFlinger.cpp

//接收DispSync的事件，转发给callback(EventThread)
fireCallbackInvocations-->callbacks[i].mCallback->onDispSyncEvent(callbacks[i].mEventTime)
@DispSync.cpp-->DispSyncSource::onDispSyncEvent-->callback->onVSyncEvent@SurfaceFlinger
-->EventThread::onVSyncEvent@EventThread.cpp


frameworks/native/services/surfaceflinger/SurfaceFlinger.cpp
frameworks/native/services/surfaceflinger/DispSync.cpp
/**************
   EventThread接收事件，并发出事件。MessageQueue监听EventThread等待事件
   	获取display的连接移除事件。从surfaceflinger获取
  	获取脉冲事件vsync。从DispSyncSource获取
   
*/
EventThread(const sp<VSyncSource>& src, SurfaceFlinger& flinger, bool interceptVSyncs){
- mVSyncSource(src),mFlinger(flinger),
- for (int32_t i=0 ; i<DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) {
	- mVSyncEvent[i].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC
	- mVSyncEvent[i].header.id = 0
	}
  //定时器
- struct sigevent se
- se.sigev_notify_function = vsyncOffCallback;
- timer_create(CLOCK_MONOTONIC, &se, &mTimerId)
}@EventThread.cpp

//app或者surfaceFlinger获取vsync, 建立连接connection(相当一个listener)
sp<IDisplayEventConnection> SurfaceFlinger::createDisplayEventConnection(ISurfaceComposer::VsyncSource vsyncSource) {
- if (vsyncSource == eVsyncSourceSurfaceFlinger) {
	- return mSFEventThread->createEventConnection()//surfaceflinger
  else{
	- return mEventThread->createEventConnection()	//app
  }
}@SurfaceFlinger.cpp

EventThread::createEventConnection()-->new Connection(const_cast<EventThread*>(this)){
- count(-1)						//vsync事件，请求一次发送一次
- mEventThread(eventThread)
- mChannel(gui::BitTube::DefaultSize)
}

EventThread::Connection::onFirstRef()-->mEventThread->registerDisplayEventConnection(this)-->
EventThread::registerDisplayEventConnection(const sp<EventThread::Connection>& connection){
- mDisplayEventConnections.add(connection)
- mCondition.broadcast()
}@EventThread.cpp

//使能vsync
enableVSyncLocked() { 
  //设置DispSyncSource的回调，从DispSyncThread
- mVsyncEnabled = true
- mVSyncSource->setCallback(static_cast<VSyncSource::Callback*>(this))
- mVSyncSource->setVSyncEnabled(true)
  //
- sendVsyncHintOnLocked(){
	- mPowerHAL.vsyncHint(true)
	- struct itimerspec ts	
	- ts.it_value.tv_nsec = vsyncHintOffDelay 	//40ms
	- timer_settime(mTimerId, 0, &ts, NULL)
	}
}@EventThread.cpp

//请求帧同步事件.请求一次发送一次
EventThread::Connection::requestNextVsync()-->mEventThread->requestNextVsync(this){
- mFlinger.resyncWithRateLimit()
- if (connection->count < 0) {
	- connection->count = 0				//默认值为-1(不发送vsync)，0(发送一次vsync)
	- mCondition.broadcast()
	}
}@EventThread.cpp


//收到DispSyncSource发出的事件。封装发送给client。帧同步信号
fireCallbackInvocations-->callbacks[i].mCallback->onDispSyncEvent(callbacks[i].mEventTime)
@DispSync.cpp-->DispSyncSource::onDispSyncEvent@SurfaceFlinger.cpp-->
onVSyncEvent(nsecs_t timestamp) {
  //将事件封装mVSyncEvent。0表示primary显示器
- mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC
- mVSyncEvent[0].header.timestamp = timestamp
- mCondition.broadcast()
}@EventThread.cpp

//发送display拔插事件
SurfaceFlinger::handleTransactionLocked(eDisplayTransactionNeeded)-->mEventThread->onHotplugReceived(draw[i].type, false)@SurfaceFlinger.cpp
onHotplugReceived(int type, bool connected) {
- DisplayEventReceiver::Event event
- event.header.type = DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG
- mPendingEvents.add(event)
- mCondition.broadcast()
}@EventThread.cpp

//从mVSyncEvent获取并处理事件。发出事件，MessageQueue中监听EventThread
onFirstRef()-->run("EventThread",)-->
EventThread::threadLoop() {
  //等待获取event，有底层上报事件会调动onVSyncEvent通知
- Vector< sp<EventThread::Connection> > signalConnections =  waitForEvent(&event)
  //发出vsync事件
- for (size_t i=0 ; i<signalConnections.size() ; i++) {
	- const sp<Connection>& conn(signalConnections[i])
	  //发送给指定channel(每个client不同channel)，MessageQueue中监听EventThread并读取
	- status_t err = conn->postEvent(event)-->DisplayEventReceiver::sendEvents(&mChannel, &event, 1){
			- gui::BitTube::sendObjects(dataChannel, events, count)		
			}
	}
}@EventThread.cpp

Vector< sp<EventThread::Connection> > EventThread::waitForEvent(DisplayEventReceiver::Event* event){//等待获取event
  //是否有vsync事件
- for (int32_t i=0 ; i<DisplayDevice::NUM_BUILTIN_DISPLAY_TYPES ; i++) {
	- timestamp = mVSyncEvent[i].header.timestamp
	- *event = mVSyncEvent[i]
	}
  //是否有其它事件。热插拔
- if (!timestamp) {
	- eventPending = !mPendingEvents.isEmpty();
	- *event = mPendingEvents[0]
        }
  //是否有client等待事件
- size_t count = mDisplayEventConnections.size()
- for (size_t i=0 ; i<count ; i++) {
	- sp<Connection> connection(mDisplayEventConnections[i].promote())
	- if (timestamp) {
		- signalConnections.add(connection)
		}
	}
  //打开关闭vsync
- if (timestamp && !waitForVSync) {						//收到事件却没有client
	- disableVSyncLocked()
  }else if (!timestamp && waitForVSync){					//有client
	- enableVSyncLocked()
  }
  //发出事件
- if (!timestamp && !eventPending) {
	- if (waitForVSync) {
		- nsecs_t timeout = softwareSync ? ms2ns(16) : ms2ns(1000) 	//16ms,一直等不到硬件vsync,主动产生一个事件
		- if (mCondition.waitRelative(mLock, timeout) == TIMED_OUT) {	//等待事件，
			- mVSyncEvent[0].header.type = DisplayEventReceiver::DISPLAY_EVENT_VSYNC
			- mVSyncEvent[0].header.id = DisplayDevice::DISPLAY_PRIMARY
			}
	  }else{//不等待vsysn，继续睡眠
		- mCondition.wait(mLock)
		}
	}
- return signalConnections
}@EventThread.cpp


frameworks/native/services/surfaceflinger/EventThread.cpp


/*******
   上层应用获取display事件
   DisplayEventReceiver
   从EventThread获取帧同步事件

*/
//创建displayEvent接收器：
new Choreographer-->new FrameDisplayEventReceiver(VSYNC_SOURCE_SURFACE_FLINGER/VSYNC_SOURCE_APP/*两种源*/)@Choregrapher.java-->
DisplayEventReceiver(Looper looper, int vsyncSource) {
- mMessageQueue = looper.getQueue
  //创建receiver，mMessageQueue用于事件读取
- mReceiverPtr = nativeInit(this, mMessageQueue,vsyncSource){
	- 转换成本地消息队列，android_os_MessageQueue_getMessageQueue
	- receiver= new NativeDisplayEventReceiver(env,receiverWeak, messageQueue, vsyncSource)-->DisplayEventDispatcher
	- receiver->initialize(){
		- mLooper->addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT,this)//监听fd,设置事件处理
		}@DisplayEventDispatcher.cpp
	}@android_view_DisplayEventReceiver.cpp
}DisplayEventReceiver.java

//创建DisplayEventDispatcher,DisplayEventReceiver
DisplayEventDispatcher(const sp<Looper>& looper,ISurfaceComposer::VsyncSource vsyncSource){
- mLooper(looper)
- mReceiver(vsyncSource)-->DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource){
	- sp<ISurfaceComposer> sf(ComposerService::getComposerService())
	- mEventConnection = sf->createDisplayEventConnection(vsyncSource)
	- mDataChannel = std::make_unique<gui::BitTube>()
	- mEventConnection->stealReceiveChannel(mDataChannel.get())
	}@DisplayEventReceiver.cpp
}@DisplayEventDispatcher.cpp


//请求事件。发送请求才会收到vsync。请求一次接收一次
scheduleVsync@DisplayEventReceiver.java-->nativeScheduleVsync-->receiver->scheduleVsync-->
NativeDisplayEventReceiver::scheduleVsync@android_view_DisplayEventReceiver.cpp-->
DisplayEventDispatcher::scheduleVsync-->mReceiver.requestNextVsync()@DisplayEventDispatcher.cpp-->
DisplayEventReceiver::requestNextVsync-->mEventConnection->requestNextVsync()@DisplayEventReceiver.cpp

//looper中读取到事件并回调处理：
Looper::pollInner-->response.request.callback->handleEvent-->
DisplayEventDispatcher::handleEvent(int, int events, void*){
  //读取事件
- processPendingEvents(&vsyncTimestamp, &vsyncDisplayId, &vsyncCount){
	- mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)
	- dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected)
  	}
  //分发vsync事件
- dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount){
	- NativeDisplayEventReceiver::dispatchVsync@android_view_DisplayEventReceiver.cpp-->dispatchVsync-->onVsync@DisplayEventReceiver.java
	}
}@DisplayEventReceiver.cpp



frameworks/base/core/java/android/view/Choreographer.java
frameworks/base/core/java/android/view/DisplayEventReceiver.java
frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp
frameworks/native/libs/gui/DisplayEventReceiver.cpp
frameworks/base/libs/androidfw/DisplayEventDispatcher.cpp

