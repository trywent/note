/* 上层接口
   获取display信息
*/
//通过resource获取分辨率
getResources-->mResource@ContextImpl.java-->getDisplayMetrics-->mResourcesImpl.getDisplayMetrics()@Resource.java

//通过display获取分辨率 android8.0
getWindowManager-->mWindowManager@Activity.java-->mWindowManager@Window.java-->WindowManagerImpl@WindowManagerImpl.java

getDefaultDisplay@WindowManagerImpl.java-->mContext.getDisplay()-->getDisplay-->mResourcesManager.getAdjustedDisplay
@ContextImpl.java-->getAdjustedDisplay@ResourceManager.java

//最终调用到getAdjustedDisplay
getAdjustedDisplay{
- DisplayManagerGlobal dm = DisplayManagerGlobal.getInstance(){
	  //只创建一个实例
	- IBinder b = ServiceManager.getService(Context.DISPLAY_SERVICE)
	- sInstance = new DisplayManagerGlobal(IDisplayManager.Stub.asInterface(b))
	}
- dm.getCompatibleDisplay(displayId, resources){
	- DisplayInfo displayInfo = getDisplayInfo(displayId){
		- info = mDm.getDisplayInfo(displayId) //从服务端获取displayInfo
		- registerCallbackIfNeededLocked	
		}
	- return new Display(this, displayId, displayInfo, daj)
	}@DisplayManangerGlobal.java
}@ResourceManager.java

//获取display android6.1
getWindowManager(dm.getDisplay)@ContextImpl.java-->getDisplay-->getOrCreateDisplayLocked
@DisplayManager.java-->getCompatibleDisplay{
- getDisplayInfo-->mDm.getDisplayInfo-->display.getDisplayInfoLocked@DisplayManagerService.java
- new Display(displayInfo)
}@DisplayManagerGlobal.java


/* DisplayEventReceiver
   获取帧同步事件

*/
//创建displayEvent接收器：
new Choreographer-->new FrameDisplayEventReceiver(VSYNC_SOURCE_SURFACE_FLINGER/VSYNC_SOURCE_APP/*两种源*/)@Choregrapher.java-->
DisplayEventReceiver(Looper looper, int vsyncSource) {
- mMessageQueue = looper.getQueue
  //创建receiver，mMessageQueue用于事件读取
- mReceiverPtr = nativeInit(this, mMessageQueue,vsyncSource){
	- 转换成本地消息队列，android_os_MessageQueue_getMessageQueue
	- receiver= new NativeDisplayEventReceiver(env,receiverWeak, messageQueue, vsyncSource)-->DisplayEventDispatcher
	- receiver->initialize(){
		- mLooper->addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT,this)//监听fd,设置事件处理
		}@DisplayEventDispatcher.cpp
	}@android_view_DisplayEventReceiver.cpp
}DisplayEventReceiver.java

//创建DisplayEventDispatcher,DisplayEventReceiver
DisplayEventDispatcher(const sp<Looper>& looper,ISurfaceComposer::VsyncSource vsyncSource){
- mLooper(looper)
- mReceiver(vsyncSource)-->DisplayEventReceiver(ISurfaceComposer::VsyncSource vsyncSource){
	- sp<ISurfaceComposer> sf(ComposerService::getComposerService())
	- mEventConnection = sf->createDisplayEventConnection(vsyncSource)
	- mDataChannel = std::make_unique<gui::BitTube>()
	- mEventConnection->stealReceiveChannel(mDataChannel.get())
	}@DisplayEventReceiver.cpp
}@DisplayEventDispatcher.cpp


//请求事件。发送请求才会收到vsync。请求一次接收一次
scheduleVsync@DisplayEventReceiver.java-->nativeScheduleVsync-->receiver->scheduleVsync-->
NativeDisplayEventReceiver::scheduleVsync@android_view_DisplayEventReceiver.cpp-->
DisplayEventDispatcher::scheduleVsync-->mReceiver.requestNextVsync()@DisplayEventDispatcher.cpp-->
DisplayEventReceiver::requestNextVsync-->mEventConnection->requestNextVsync()@DisplayEventReceiver.cpp

//looper中读取到事件并回调处理：
Looper::pollInner-->response.request.callback->handleEvent-->
DisplayEventDispatcher::handleEvent(int, int events, void*){
  //读取事件
- processPendingEvents(&vsyncTimestamp, &vsyncDisplayId, &vsyncCount){
	- mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)
	- dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected)
  	}
  //分发vsync事件
- dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount){
	- NativeDisplayEventReceiver::dispatchVsync@android_view_DisplayEventReceiver.cpp-->dispatchVsync-->onVsync@DisplayEventReceiver.java
	}
}@DisplayEventReceiver.cpp



frameworks/base/core/java/android/view/Choreographer.java
frameworks/base/core/java/android/view/DisplayEventReceiver.java
frameworks/base/core/jni/android_view_DisplayEventReceiver.cpp
frameworks/native/libs/gui/DisplayEventReceiver.cpp
frameworks/base/libs/androidfw/DisplayEventDispatcher.cpp


