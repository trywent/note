/******************************************

Generic Access Profile(GAP)
Advanced Audio Distribution Profile (A2DP) //使用
A/V Distribution Transport Protocol (AVDTP) //音频视频流的连接和传输
Generic Audio/Video Distribution Profile (GAVDP) //使用ACDTP
Video Distribution Profile (VDP)
Audio/Video Control Transport Protocol specification(AVCTP) //音频视频流的控制
Audio/Video Remote Control Profile (AVRCP) //使用AVCTP传输.定义了控制命令，格式.

GAP{
- GAVDP{
   - A2DP
   - VDP
  }
- AVRCP
}

*/


/******************************************
OPP：文件传输规范
hfp：和电话相关，接听、挂断电话，以及连接sco通路
a2dp：蓝牙立体声规范，其中包含avrcp规范，avrcp规范实现了听歌时暂停、上下歌曲选择等控制模式。目前蓝牙耳机一般都支持这两种规范。
hid：人机交互规范，蓝牙鼠标键盘等
phap：电话号码簿访问协议
hdp：蓝牙医疗相关规范

//bluetooth stack
bta - Bluetooth Application
btcore - Bluetooth Core
btif - Bluetooth Interface
btu - Bluetooth Upper Layer  对L2CAP RFCOMM, SDP and the BTIf封装？
btm - Bluetooth Manager 
BTE: Bluetooth embedded system

CO: call out
CI: call in
HF : Handsfree Profile
HH: HID Host Profile
HL: Health Device Profile
AV:audio\vidio
ag: audio gateway
ar: audio/video registration
gattc: GATT client
BLE: Bluetooth Low Energy

snoop log 开关BLUETOOTH_BTSNOOP_ENABLE_PROPERTY "persist.bluetooth.btsnoopenable"
*******************************************/
/* 
  jni到bluetooth库中的接口和回调
  bluetoothInterface
  sBluetoothCallbacks
*/

//加载蓝牙库。获取接口sBluetoothInterface
static{classInitNative}@AdapterService.java-->
classInitNative{
- jniCallbackClass = env->FindClass("com/android/bluetooth/btservice/JniCallbacks")//获取回调类
- sJniCallbacksField ,method_stateChangeCallback，method_adapterPropertyChangedCallback//初始化一些回调方法JniCallbacks
- hw_get_module(BT_STACK_MODULE_ID,&module)//hal层
- module->methods->open(module，abstraction) //获取协议栈
- btStack = (bluetooth_module_t *)abstraction //协议栈
- sBluetoothInterface = btStack->get_bluetooth_interface //协议栈调用接口bluetooth_interface@bluetooth.c
}@com_android_bluetooth_btservice_AdapterService.cpp

hw_module_t HAL_MODULE_INFO_SYM = {
    .id = BT_HARDWARE_MODULE_ID,
    .methods = &bt_stack_module_methods
}@bluetooth.c

//获取栈接口后,初始化栈,并设置回调函数
onCreate@AdapterService.java-->
initNative{
- sBluetoothInterface->init(sBluetoothCallbacks)  //设置协议栈回调
- sBluetoothInterface->set_os_callouts(sBluetoothOsCallouts)  //系统相关回调,睡眠锁
- sBluetoothSocketInterface = sBluetoothInterface->get_profile_interface(BT_PROFILE_SOCKETS_ID){//获取socket接口
	- btif_hf_get_interface        //hf
	- btif_hf_client_get_interface //hf client
	- btif_av_get_src_interface    //a2dp
	- btif_av_get_sink_interface   //a2dp sink
	}

}@com_android_bluetooth_btservice_AdapterService.cpp

//java--jni--stack接口
static const bt_interface_t bluetoothInterface = {
    sizeof(bluetoothInterface),
    init,
    enable,
    cleanup,
    get_adapter_properties,
    get_adapter_property,
    set_adapter_property,
    get_remote_device_properties,
    get_remote_device_property,
    set_remote_device_property,
    get_remote_service_record,
    get_remote_services,
    start_discovery,
    cancel_discovery,
    create_bond,
    remove_bond,
    cancel_bond,
    get_connection_state,
    pin_reply,
    ssp_reply,
}@bluetooth.c

//stack--jni--java的回调接口
static bt_callbacks_t sBluetoothCallbacks = {
    sizeof(sBluetoothCallbacks),
    adapter_state_change_callback,
    adapter_properties_callback,
    remote_device_properties_callback,
    device_found_callback,
    discovery_state_changed_callback,
    pin_request_callback,
    ssp_request_callback,
    bond_state_changed_callback,
    acl_state_changed_callback,
    callback_thread_event,
    dut_mode_recv_callback,
    le_test_mode_recv_callback,
    energy_info_recv_callback
}@com_android_bluetooth_btservice_AdapterService.cpp



/*******************************************
stack初始化
创建"stack_manager"线程,
创建BT_JNI_WORKQUEUE_NAME线程,底层回调java

threadpost(thread,function) //线程切换

设置stack回调java接口，
创建stack_manager初始化stack


*******************************************/
initNative-->bluetoothInterface->init(sBluetoothCallbacks){
- bt_hal_cbacks = callbacks //设置回调
- stack_manager_get_interface{
	- ensure_manager_initialized-->management_thread = thread_new("stack_manager") //创建 management_thread线程
	- return interface //stack接口，栈初始化
	}
- init_stack-->thread_post(management_thread, event_init_stack)-->event_init_stack{
	- btif_init_bluetooth{
		- bt_jni_workqueue_thread = thread_new(BT_JNI_WORKQUEUE_NAME) 
		}@btif_core.c
	}@stack_manager.c
}@bluetooth.c

/*
 jni回调线程。用于回调java接口

*/
//btif BT_JNI_WORKQUEUE_NAME线程.用于底层回调到java
btif_init_bluetooth{
- bt_jni_workqueue_thread = thread_new(BT_JNI_WORKQUEUE_NAME)
- thread_post(bt_jni_workqueue_thread, run_message_loop)-->
	run_message_loop{
	- message_loop_ = new base::MessageLoop
	- jni_run_loop = new base::RunLoop()
  	- jni_run_loop->Run()
	}
}@btif_core.c

//底层调用切换到当前jni线程.回调上层
btif_transfer_context(p_cback,event,p_params){
- p_msg->hdr.event = BT_EVT_CONTEXT_SWITCH_EVT
- p_msg->p_cb = p_cback
- btif_sendmsg-->do_in_jni_thread-->bt_jni_msg_ready(BT_EVT_CONTEXT_SWITCH_EVT)-->
	btif_context_switched(p_msg)--p_msg->pcb(event)
}

btif_thread_post


/*******************************************
 打开蓝牙
 设置btu新线程BT_WORKQUEUE_NAME.用于执行上层调用stack接口bta

*******************************************/
enable-->stack_manager_get_interface()->start_up_stack_async@bluetooth.c-->
thread_post(management_thread, event_start_up_stack)-->event_start_up_stack{
- ensure_stack_is_initialized-->event_init_stack
- module_start_up(get_module(BTIF_CONFIG_MODULE)
- bte_main_enable{
	- module_start_up(get_module(BTSNOOP_MODULE))-->btsnoop_module.start_up@btsnoop.c
	- module_start_up(get_module(HCI_MODULE))-->hci_module.start_up@hci_layer.c
	- BTU_StartUp@btu_init.c
	}@bte_main.c
- btif_thread_post(event_signal_stack_up)-->do_in_jni_thread(event_signal_stack_up)//回调上层
}@stack_manager.c

//启动BT_WORKQUEUE_NAME
BTU_StartUp{
- bt_workqueue_thread = thread_new(BT_WORKQUEUE_NAME)//新线程
- thread_post(bt_workqueue_thread, btu_task_start_up)-->btu_task_start_up@btu_task.c
}@btu_init.c

btu_task_start_up{//新线程中启动
- btu_init_core{
	- btm_init //btm初始
	- l2c_init
	- sdp_init
	- gatt_init
	- btm_ble_init
	}@btu_init.c
- BTE_InitStack{
	- RFCOMM_Init
	- A2DP_Init
	- AVRC_Init
	}
- bta_sys_init
  //创建新线程
- message_loop_thread_ = thread_new("btu message loop")
  //开始循环处理message 
- thread_post(message_loop_thread_, btu_message_loop_run)-->btu_message_loop_run{
	- message_loop_ = new base::MessageLoop()
	- run_loop_ = new base::RunLoop()
	- run_loop_->Run()
	}
}@btu_task.c




system/bt/btif/src/bluetooth.c
system/bt/btif/src/stack_manager.c
system/bt/main/bte_main.c
system/bt/stack/btu/btu_init.c
btif/src/btif_dm.c
bta/dm/bta_dm_api.c
bta/sys/bta_sys_main.c

system/bt/btif/src/btif_core.c

system/bt/hci/src/hci_layer.c
system/bt/hci/src/btsnoop.c

system/bt/stack/btu/btu_init.c
system/bt/stack/btu/btu_task.c

//operation system interface
osi/src/fixed_queue.c


