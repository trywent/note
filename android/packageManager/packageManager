/*
 SystemConfig 配置，功能，权限
 mSetting 保存应用信息

 MATCH_DIRECT_BOOT_UNAWARE
 MATCH_DIRECT_BOOT_AWARE
*/
//启动
startBootstrapServices{
- Installer installer = mSystemServiceManager.startService(Installer.class)
- mPackageManagerService = PackageManagerService.main(mSystemContext, installer,mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore)
}@SystemServer.java

main(Context context, Installer installer,boolean factoryTest, boolean onlyCore){
- PackageManagerService m = new PackageManagerService(context, installer,factoryTest, onlyCore)
- ServiceManager.addService("package", m)
}@PackageManagerService.java


//PackageManagerService
final ArrayMap<String, PackageParser.Package> mPackages = new ArrayMap<String, PackageParser.Package>

PackageManagerService(Context context, Installer installer,
            boolean factoryTest, boolean onlyCore){
- mSettings = new Settings(mPackages)
- mInstaller = installer
- mPackageDexOptimizer = new PackageDexOptimizer(installer)
- mDexManager = new DexManager(this, mPackageDexOptimizer, installer)
  //读取system,vendor,odm,oem配置，权限
- SystemConfig systemConfig = SystemConfig.getInstance()-->new SystemConfig{
	- readPermissions(Environment.buildPath(Environment.getRootDirectory(), "etc", "sysconfig"), ALLOW_ALL)
	- readPermissions(Environment.buildPath(Environment.getVendorDirectory(), "etc", "sysconfig"), vendorPermissionFlag)
	}
- mGlobalGids = systemConfig.getGlobalGids()
- mSystemPermissions = systemConfig.getSystemPermissions()
- mAvailableFeatures = systemConfig.getAvailableFeatures()
 //处理应用
- mHandlerThread = new ServiceThread(TAG,Process.THREAD_PRIORITY_BACKGROUND)
- mHandlerThread.start()
- sUserManager = new UserManagerService(context, this,new UserDataPreparer(mInstaller, mInstallLock, mContext, mOnlyCore))
 //读取用户设置 
- mFirstBoot = !mSettings.readLPw(sUserManager.getUsers(false))
- requestCopyPreoptedFiles //copy files
  //扫描应用
- scanDirTracedLI
  //应用安装
- mInstallerService = new PackageInstallerService(context, this)
}@PackageManagerService.java





resolveIntent(Intent intent, String resolvedType,int flags, int userId)-->
resolveIntentInternal{
  //更新flag
- flags = updateFlagsForResolve(flags, userId, intent, callingUid, resolveForStart)-->
	updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid,
            boolean wantInstantApps, boolean onlyExposedExplicitly)
- List<ResolveInfo> query = queryIntentActivitiesInternal(intent, resolvedType, flags)
- esolveInfo bestChoice = chooseBestActivity(intent, resolvedType, flags, query)
- return bestChoice
}@PackageManagerService.java

updateFlagsForResolve(int flags, int userId, Intent intent, int callingUid,
            boolean wantInstantApps, boolean onlyExposedExplicitly){
- if (getInstantAppPackageName(callingUid) != null) {
  	- flags |= PackageManager.MATCH_VISIBLE_TO_INSTANT_APP_ONLY
	- flags |= PackageManager.MATCH_INSTANT
  else{
	- flags &= ~(PackageManager.MATCH_VISIBLE_TO_INSTANT_APP_ONLY
                    | PackageManager.MATCH_EXPLICITLY_VISIBLE_ONLY)
  } 
- updateFlagsForComponent{
	- updateFlags{
		- 已经设置MATCH_DIRECT_BOOT_UNAWARE|MATCH_DIRECT_BOOT_AWARE
		- 没有设置aware,unaware则，getUserManagerInternal().isUserUnlockingOrUnlocked(userId){
			- flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE | MATCH_DIRECT_BOOT_UNAWARE		
			}else
			- flags |= PackageManager.MATCH_DIRECT_BOOT_AWARE
		}
	}
}@PackageManagerService.java

//Activity 查询
queryIntentActivitiesInternal(Intent intent,
            String resolvedType, int flags, int filterCallingUid, int userId,
            boolean resolveForStart, boolean allowDynamicSplits, boolean bool) {
  //intent是否包含包名，component
- String pkgName = intent.getPackage()
- ComponentName comp = intent.getComponent()
  //component不为空
- if (comp != null) {
	- List<ResolveInfo> list = new ArrayList<ResolveInfo>(1)
	- ActivityInfo ai = getActivityInfo(comp, flags, userId)-->getActivityInfoInternal
	- return applyPostResolutionFilter
	}
- List<ResolveInfo> result

- synchronized (mPackages){
  //packageName为空
  {//crossprofile,先查找过滤当前用户的匹配
- List<CrossProfileIntentFilter> matchingFilters = getMatchingCrossProfileIntentFilters(intent)
- ResolveInfo xpResolveInfo  = querySkipCurrentProfileIntents(matchingFilters, intent)  
- result = filterIfNotSystemUser(mActivities.queryIntent(intent, resolvedType, flags, userId), userId)//查找
  }
  //packageName不为空
- filterIfNotSystemUser(mActivities.queryIntentForPackage(intent, resolvedType, flags))
- 
  }//synchronized (mPackages)
}@PackageManagerService.java

/*activities 中查询

*/
ActivityIntentResolver.queryIntent(Intent intent, String resolvedType, int flags,int userId){
- mFlags = flags
- super.queryIntent(intent, resolvedType)
}

//安装
installPackageTracedLI-->installPackageLI(InstallArgs args, PackageInstalledInfo res){
- final String installerPackageName = args.installerPackageName
- final File tmpPackageFile = new File(args.getCodePath())

  //
- if (args.move != null) {

  }else(!forwardLocked && !pkg.applicationInfo.isExternalAsec()){
	- derivePackageAbi //解出库文件
  }else if(pkg.applicationInfo.isExternalAsec()){

  }
  //
- if (replace) {
	- replacePackageLIF(pkg, parseFlags, scanFlags | SCAN_REPLACING, args.user,...)
  }else{
	- installNewPackageLIF(pkg, parseFlags, scanFlags | SCAN_DELETE_DATA_ON_FAILURES...)
  }
}@PackageManagerService.java

/*
 安装应用前传输apk文件到packageManagerServices
*/

//PackageInstallerService
PackageManagerService-->PackageInstallerService(Context context, PackageManagerService pm){
- mInstallThread = new HandlerThread(TAG)
- mInstallThread.start
- mInstallHandler = new Handler(mInstallThread.getLooper())
- mCallbacks = new Callbacks(mInstallThread.getLooper())
-  mSessionsFile = new AtomicFile(new File(Environment.getDataSystemDirectory(), "install_sessions.xml"))
- mSessionsDir = new File(Environment.getDataSystemDirectory(), "install_sessions")
- mSessionsDir.mkdirs()
}@PackageInstallerService.java

//session
createSession(SessionParams params, String installerPackageName, int userId)-->
createSessionInternal(SessionParams params, String installerPackageName, int userId){
- final int sessionId = allocateSessionIdLocked()
- session = new PackageInstallerSession(mInternalCallback, mContext, mPm...){
	- - mHandler = new Handler(looper, mHandlerCallback)
	}@PackageInstallerSession.java
- mSessions.put(sessionId, session)
}@PackageInstallerService.java


//将apk文件写到一个中转区？
ParcelFileDescriptor openWriteInternal(String name, long offsetBytes, long lengthBytes){
- bridge = new FileBridge()
- mBridges.add(bridge)
- stageDir = resolveStageDirLocked()
- target = new File(stageDir, name)
- final FileDescriptor targetFd = Libcore.os.open(target.getAbsolutePath(),O_CREAT | O_WRONLY, 0644)
- bridge.setTargetFile(targetFd)
- return new ParcelFileDescriptor(bridge.getClientSocket())
}@PackageInstallerSession.java

//提交数据
commit(@NonNull IntentSender statusReceiver, boolean forTransfer){
- PackageInstallObserverAdapter adapter = new PackageInstallObserverAdapter(mContext, statusReceiver, sessionId...)
- computeProgressLocked(true)
- mHandler.obtainMessage(MSG_COMMIT).sendToTarget()-->mHandlerCallback.handleMessage()-->commitLocked
}@PackageInstallerSession.java

commitLocked{
- needToAskForPermissionsLocked
- computeProgressLocked
  //解出库文件
- extractNativeLibraries(mResolvedStageDir, params.abiOverride){
	- final File libDir = new File(packageDir, NativeLibraryHelper.LIB_DIR_NAME)
	- handle = NativeLibraryHelper.Handle.create(packageDir)
	- NativeLibraryHelper.copyNativeBinariesWithOverride(handle, libDir,abiOverride)
 	}
  //安装
- mPm.installStage(mPackageName, stageDir, stageCid, localObserver,...)
}@PackageInstallerSession.java

frameworks/base/services/core/java/com/android/server/pm/PackageInstallerService.java
frameworks/base/services/core/java/com/android/server/pm/PackageInstallerSession.java


