//AudioFlinger: 关联到实际hw设备。写播放数据到hw设备。从hw设备读取数据。


AudioFlinger{
- mDevicesFactoryHal = DevicesFactoryHalInterface::create()-->
	new DevicesFactoryHalHybrid{
	- mLocalFactory = new DevicesFactoryHalLocal
	- mHidlFactory = new DevicesFactoryHalHidl{
			- mDevicesFactory = IDevicesFactory::getService() //获取hidl接口
			}
	}
- mEffectsFactoryHal = EffectsFactoryHalInterface::create()
- onFirstRef-->mStandbyTimeInNsecs
}AudioFlinger.cpp

AudioFlinger::instantiate-->publish{
- 创建，new SERVICE
- 加入，sm->addService
}@BinderService.h

/*
 获取hal接口.
 原来的,获取模块:hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID),
	获取设备接口:audio_hw_device_open 
*/
loadHwModule(name)-->
loadHwModule_l{
- sp<DeviceHalInterface> dev //hal设备接口,primary,ad2dp,usb
- mDevicesFactoryHal->openDevice(name, &dev)-->DevicesFactoryHalHybrid::openDevice-->
  mHidlFactory->openDevice-->openDevice@DevicesFactory
- dev->setMasterVolume/dev->setMasterMute
- mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags)) //保存接口到AudioHwDevice
}



frameworks/av/media/libaudiohal/DevicesFactoryHalHybrid.cpp
frameworks/av/media/libaudiohal/DevicesFactoryHalHidl.cpp
frameworks/av/media/libaudiohal/DevicesFactoryHalLocal.cpp
============
/*openOutput 
 audiohw创建一个outStream结构
*/
openOutput-->openOutput_l(audio_module_handle_t module,audio_io_handle_t *output,audio_config_t *config,
		audio_devices_t devices, const String8& address,audio_output_flags_t flags){
//获取audiohw接口
- AudioHwDevice *outHwDev = findSuitableHwDev_l(module,devices){
	- module=0{//老方法
		- loadHwModule_l //加载module
		}
	- module!=0,AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(module) //从mAudioHwDevs查找并返回
	}

- outHwDev->openOutputStream(&ppStreamOut/*output*/,device){
	- AudioStreamOut *outputStream = new AudioStreamOut(this)
	- outputStream->open(handle, devices, config, address){
		- sp<StreamOutHalInterface> outStream
		- hwDev()->openOutputStream(&outStream)
		- stream = outStream
		}
	- ppStreamOut = outputStream 
	}@AudioHwDevice.cpp
- new MixerThread(this, outputStream, *output/*playThread的句柄*/) //创建thread
- mPlaybackThreads.add(*output, thread)
}@AudioFlinger.cpp


//在Thread中有多个tracks对应着client。通过tracks中的数据混合后写到hal层
//1,创建audioTrack  audioPolicy创建应用端的audioTrack
AudioFlinger::createTrack(output){
- 检查参数，检查格式audio_is_linear_pcm
- 根据output获取playbackThread，checkPlaybackThread_l //获取output对应的thread
- 根据进程id，创建client。registerPid_l{
		- client = new Client-->new MemoryDealer//用于分配内存，heap由ro.af.client_heap_size_kbyte定义
		- mClients.add(client)		
		}
- 创建track，thread->createTrack_l-->AudioFlinger::PlaybackThread::createTrack_l(client){
	- new Track()@Tracks.cpp
	}@Threads.cpp
- 创建new TrackHandle(track)，并返回
}

PlaybackThread::createTrack_l{
- 创建，new Track(StreamType，client){
	- 计算需要的memory大小，audio_track_cblk_t+buffersize
	- mCblk = mCblkMemory = client->heap()->allocate-->MemoryDealer->allocate
	- 设置mBuffer的位置 //ALLOC_CBLK mBuffer = mCblk + audio_track_cblk_t
	}
- 加入容器，mTracks.add
}@Threads.cpp

//创建imem 用于写数据
AudioFlinger::TrackHandle::getCblk-->mTrack->getCblk@Tracks.cpp
--mCblkMemory@Trackbase.h

//3,play  加入到mActiveTracks
start(跨进程)：
AudioFlinger::TrackHandle::start-->mTrack->start-->AudioFlinger::PlaybackThread::Track::start{
- mThread.promote
- 更新状态mState
- playbackThread->addTrack_l(this)@Tracks.cpp-->addTrack_l{//加入到mActiveTracks
	- 若mActiveTracks中没有加入
	- AudioSystem::startOutput //开始播放？
	- 加入mActiveTracks.add
	}@Threads.cpp
}@Tracks.cpp

//移除mActiveTracks
AudioFlinger::MixerThread::prepareTracks_l-->removeTracks_l-->mActiveTracks.remove(track)


//设置音量
setStreamVolume-->mPlaybackThreads.valueAt(i)->setStreamVolume@AudioFlinger.cpp-->
AudioFlinger::PlaybackThread::setStreamVolume-->设置mStreamTypes[stream].volume@Threads.cpp

PlaybackThread::threadLoop-->prepareTracks_l{
- (设置音量)track->mCachedVolume
- typeVolume = mStreamTypes[track->streamType()].volume
}@Threads.cpp

(猜测是在这里)mFastMixer->run-->FastMixer::threadLoop(fastTrack->mVolumeProvider->getVolumeLR)

setMasterVolume@System.java-->android_media_AudioSystem_setMasterVolume-->AudioSystem::setMasterVolume
-->setMasterVolume-->dev->hwDevice()->set_master_volume@AudioFlinger.cpp

//设置muster mute
AudioSystem::setMasterMute
AudioFlinger::setMasterMute-->dev->hwDevice()->set_master_mute@AudioFlinger.cpp


===============
/*input
* 保存input数据的buffer在audioflinger侧分配，client(AudioRecord端)获取这个buffer读取数据
* IMemory 进程间拷贝数据。
*/
AudioFlinger::openInput-->openInput_l{
- inHwHal->open_input_stream{//打开input流，设置input的配置

	}
- new AudioStreamIn //创建流
- new RecordThread  //创建线程
- mRecordThreads.add(*input, thread) //加入容器
}


AudioFlinger::openRecord{
- checkRecordThread_l //获取input对应的线程
- client = registerPid(pid)//创建clinet 用于分配内存(4K大小)
- thread->createRecordTrack_l-->RecordTrack@Thread.cpp-->
	TrackBase::TrackBase{
	- client->heap()->allocate@Tracks.cpp-->MemoryDealer->allocate//mBuffer
	- 
	}
	RecordTrack{
	- RecordBufferConverter 
	- AudioRecordServerProxy(mCblk,mBuffer)
	}@Tracks.cpp
- recordTrack->getBuffers-->mBufferMemory(返回)@TrackBase.h //获取buffer
}


RecordThread::start-->AudioSystem::startInput@AudioFlinger.cpp

//读取数据
AudioFlinger::RecordThread::threadLoop{
- 
- activeTrack->getNextBuffer(&activeTrack->mSink){//获取buffer
	- mServerProxy->obtainBuffer
	- 
	}@Tracks.cpp
- mInput->stream->read(mInput->stream,mRsmpInBuffer) //读取数据，hw->read start_input
- activeTrack->mRecordBufferConverter->convert //重采样,将数据拷贝到客户端buffer中
}@Threads.cpp

//重采样，拷贝hal层数据到client
AudioFlinger::RecordThread::RecordBufferConverter::convert-->provider->getNextBuffer
-->AudioFlinger::RecordThread::ResamplerBufferProvider::getNextBuffer


//回调设置参数
setParameters-->thread->setParameters@AudioFlinger.cpp-->MixerThread::checkForNewParameters_l
mOutput->stream->common.set_parameters@Threads.cpp-->out_set_parameters@audio_hw_hal.cpp-->
setParameters@AudioHardware.cpp



frameworks/av/services/audioflinger/AudioFlinger.cpp
frameworks/av/services/audioflinger/AudioHwDevice.cpp
frameworks/av/services/audioflinger/AudioStreamOut.cpp
frameworks/av/services/audioflinger/Threads.cpp
frameworks/av/services/audioflinger/Tracks.cpp
frameworks/native/libs/binder/IMemory.cpp
