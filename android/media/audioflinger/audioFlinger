/***************************************************
 AudioFlinger 提供的接口。patch相关接口在PatchPanel中实现

*/
sp<IAudioTrack> createTrack(const CreateTrackInput& input, CreateTrackOutput& output,status_t *status);
sp<media::IAudioRecord> createRecord(const CreateRecordInput& input, CreateRecordOutput& output,status_t *status)
status_t    setStreamVolume(audio_stream_type_t stream, float value,audio_io_handle_t output)	//stream
status_t    setStreamMute(audio_stream_type_t stream, bool muted)
status_t    setMicMute(bool state)								//mic
bool        getMicMute() const
status_t openOutput(audio_module_handle_t module,audio_io_handle_t *output...)			//output
audio_io_handle_t openDuplicateOutput(audio_io_handle_t output1, audio_io_handle_t output2)
status_t closeOutput(audio_io_handle_t output)
status_t openInput(audio_module_handle_t module,audio_io_handle_t *input....)			//input		
status_t closeInput(audio_io_handle_t input)

status_t queryEffect(uint32_t index, effect_descriptor_t *descriptor) const			//effect
status_t getEffectDescriptor(const effect_uuid_t *pUuid,const effect_uuid_t *pTypeUuid,...)
sp<IEffect> createEffect(effect_descriptor_t *pDesc,const sp<IEffectClient>& effectClient,..)
status_t moveEffects(audio_session_t sessionId, audio_io_handle_t srcOutput,audio_io_handle_t dstOutput)
setEffectSuspended(int effectId,audio_session_t sessionId,bool suspended) override

status_t listAudioPorts(unsigned int *num_ports, struct audio_port *ports)			//audioport
status_t getAudioPort(struct audio_port *port)
status_t createAudioPatch(const struct audio_patch *patch,audio_patch_handle_t *handle)		//patch在PatchPanel中实现
status_t releaseAudioPatch(audio_patch_handle_t handle)
status_t listAudioPatches(unsigned int *num_patches, struct audio_patch *patches)
status_t setAudioPortConfig(const struct audio_port_config *config)

frameworks/av/services/audioflinger/AudioFlinger.h
frameworks/av/media/libaudioclient/include/media/IAudioFlinger.h
frameworks/av/services/audioflinger/PatchPanel.cpp
/***************************************************
 AudioFlinger 操作hal层接口

*/

AudioFlinger{
- mDevicesFactoryHal = DevicesFactoryHalInterface::create()-->
	new DevicesFactoryHalHybrid{
	- mLocalFactory = new DevicesFactoryHalLocal
	- mHidlFactory = new DevicesFactoryHalHidl{
			- mDevicesFactory = IDevicesFactory::getService() //获取hidl接口
			}
	}
  //音效的hal操作接口
- mEffectsFactoryHal = EffectsFactoryHalInterface::create()
- onFirstRef-->mStandbyTimeInNsecs
}AudioFlinger.cpp

AudioFlinger::instantiate-->publish{
- 创建，new SERVICE
- 加入，sm->addService
}@BinderService.h

/***************************************************
 hal接口
 原来的,获取模块:hw_get_module_by_class(AUDIO_HARDWARE_MODULE_ID),
	获取设备接口:audio_hw_device_open 
*/
loadHwModule(name)-->
loadHwModule_l{
- sp<DeviceHalInterface> dev //hal设备接口,primary,ad2dp,usb
- mDevicesFactoryHal->openDevice(name, &dev)-->DevicesFactoryHalHybrid::openDevice-->
  mHidlFactory->openDevice-->openDevice@DevicesFactory
- dev->setMasterVolume/dev->setMasterMute
- mAudioHwDevs.add(handle, new AudioHwDevice(handle, name, dev, flags)) //保存接口到AudioHwDevice
}



frameworks/av/media/libaudiohal/DevicesFactoryHalHybrid.cpp
frameworks/av/media/libaudiohal/DevicesFactoryHalHidl.cpp
frameworks/av/media/libaudiohal/DevicesFactoryHalLocal.cpp
/***************************************************
 openOutput 
 audiohw创建一个outStream结构
*/
openOutput-->openOutput_l(audio_module_handle_t module,audio_io_handle_t *output,audio_config_t *config,
		audio_devices_t devices, const String8& address,audio_output_flags_t flags){
//获取audiohw接口
- AudioHwDevice *outHwDev = findSuitableHwDev_l(module,devices){
	- module=0{//老方法
		- loadHwModule_l //加载module
		}
	- module!=0,AudioHwDevice *audioHwDevice = mAudioHwDevs.valueFor(module) //从mAudioHwDevs查找并返回
	}

- outHwDev->openOutputStream(&ppStreamOut/*output*/,device){
	- AudioStreamOut *outputStream = new AudioStreamOut(this)
	- outputStream->open(handle, devices, config, address){
		- sp<StreamOutHalInterface> outStream
		- hwDev()->openOutputStream(&outStream)
		- stream = outStream
		}
	- ppStreamOut = outputStream 
	}@AudioHwDevice.cpp
- if(flags & AUDIO_OUTPUT_FLAG_MMAP_NOIRQ){
	- sp<MmapPlaybackThread> thread = new MmapPlaybackThread(this, *output, outHwDev, outputStream,devices, AUDIO_DEVICE_NONE)
	- mMmapThreads.add(*output, thread)
  }else{
	- sp<PlaybackThread> thread
	- if (flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) {
		- thread = new OffloadThread(this, outputStream, *output, devices, mSystemReady)
	 }else((flags & AUDIO_OUTPUT_FLAG_DIRECT)||!isValidPcmSinkFormat(config->format)){
		- thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady)
	 }else{
		- thread = new MixerThread(this, outputStream, *output/*playThread的句柄*/) //创建thread
	  }
  }
  //保存到mPlaybackThreads
- mPlaybackThreads.add(*output, thread)
}@AudioFlinger.cpp


//在Thread中有多个tracks对应着client。通过tracks中的数据混合后写到hal层
//1,创建audioTrack  audioPolicy创建应用端的audioTrack
AudioFlinger::createTrack(output){
- 检查参数，检查格式audio_is_linear_pcm
- 根据output获取playbackThread，checkPlaybackThread_l //获取output对应的thread
- sp<Client> client = registerPid(clientPid){
		- client = new Client-->new MemoryDealer//用于分配内存，heap由ro.af.client_heap_size_kbyte定义
		- mClients.add(client)		
		}
- track= thread->createTrack_l-->AudioFlinger::PlaybackThread::createTrack_l(client){
	- new Track()@Tracks.cpp
	}@Threads.cpp
- 创建new TrackHandle(track)，并返回
}

PlaybackThread::createTrack_l{
- 创建，new Track(StreamType，client)-->TrackBase{
	- 计算需要的memory大小，audio_track_cblk_t+buffersize
	- mCblk = mCblkMemory = client->heap()->allocate-->MemoryDealer->allocate
	- 设置mBuffer的位置 //ALLOC_CBLK mBuffer = mCblk + audio_track_cblk_t
	}@Track.cpp
- 加入容器，mTracks.add
}@Threads.cpp

//创建imem 用于写数据
AudioFlinger::TrackHandle::getCblk-->mTrack->getCblk@Tracks.cpp
--mCblkMemory@Trackbase.h

//3,play  加入到mActiveTracks
start(跨进程)：
AudioFlinger::TrackHandle::start-->mTrack->start-->AudioFlinger::PlaybackThread::Track::start{
- mThread.promote
- 更新状态mState
- playbackThread->addTrack_l(this)@Tracks.cpp-->addTrack_l{//加入到mActiveTracks
	- 若mActiveTracks中没有加入
	- AudioSystem::startOutput //开始播放？
	- 加入mActiveTracks.add
	}@Threads.cpp
}@Tracks.cpp

//移除mActiveTracks
AudioFlinger::MixerThread::prepareTracks_l-->removeTracks_l-->mActiveTracks.remove(track)


//设置音量
AudioFlinger::setStreamVolume(audio_stream_type_t stream, float value,audio_io_handle_t output){
- checkStreamType(stream)
- Vector<VolumeInterface *> volumeInterfaces = getVolumeInterface_l(output){
	- VolumeInterface *volumeInterface = mPlaybackThreads.valueFor(output).get()
	- return volumeInterface
	}
- volumeInterfaces.add(volumeInterface)
- mStreamTypes[stream].volume = value
  //thread设置音量
- for (size_t i = 0; i < volumeInterfaces.size(); i++) {
	-  volumeInterfaces[i]->setStreamVolume(stream, value){
		- mStreamTypes[stream].volume = value
		}@Threads.cpp
	}
}@AudioFlinger.cpp

PlaybackThread::threadLoop-->prepareTracks_l{
- (设置音量)track->mCachedVolume
- typeVolume = mStreamTypes[track->streamType()].volume
}@Threads.cpp

(猜测是在这里)mFastMixer->run-->FastMixer::threadLoop(fastTrack->mVolumeProvider->getVolumeLR)

setMasterVolume@System.java-->android_media_AudioSystem_setMasterVolume-->AudioSystem::setMasterVolume
-->setMasterVolume-->dev->hwDevice()->set_master_volume@AudioFlinger.cpp

//设置muster mute
AudioSystem::setMasterMute
AudioFlinger::setMasterMute-->dev->hwDevice()->set_master_mute@AudioFlinger.cpp


/***************************************************
  input
 保存input数据的buffer在audioflinger侧分配，client(AudioRecord端)获取这个buffer读取数据
 IMemory 进程间拷贝数据。
*/
AudioFlinger::openInput-->openInput_l(audio_module_handle_t module,audio_io_handle_t *input,
      audio_config_t *config, audio_devices_t devices,audio_source_t source){
- *input = nextUniqueId(AUDIO_UNIQUE_ID_USE_INPUT) //input为一个handle
  //打开HAL input，设置input的配置
- inHwHal->open_input_stream(*input, devices, &halconfig,source, &inStream){
	- inStream
	}@audio_hw.c
- AudioStreamIn *inputStream = new AudioStreamIn(inHwDev, inStream)//创建流
- new RecordThread(this,inputStream,*input,devices)  //创建录音线程
- mRecordThreads.add(*input, thread) //加入容器
}


//创建RecordTrack
//建立共享内存
AudioFlinger::openRecord(audio_io_handle_t input, uint32_t sampleRate,audio_channel_mask_t channelMask,
	sp<IMemory>& cblk,sp<IMemory>& buffers,){
- checkRecordThread_l //获取input对应的线程
- sp<Client> client = registerPid(pid){//创建clinet 用于分配内存(4K大小)
	- sp<Client> client = new Client(this, pid){
		- size_t heapSize = property_get_int32("ro.af.client_heap_size_kbyte", 0) //默认堆
		- mMemoryDealer = new MemoryDealer(heapSize, "AudioFlinger::Client")
		}
	- mClients.add(pid, client)
	}
- sp<RecordThread::RecordTrack> recordTrack = thread->createRecordTrack_l(client)@Thread.cpp
- cblk = recordTrack->getCblk()
- buffers = recordTrack->getBuffers-->mBufferMemory(返回)@TrackBase.h //获取mBufferMemory,只有fast RecordTrack 
}

/****************
 内存分配
 audioflinger:通过MemoryDealer获取IMemory

  MemoryDealer{
	- 内存
	- 内存管理	
	}

  audioTrack,audioRecord:工作audioFlinger获取IMemory
*/

IMemory{
- void* pointer(){ //获取地址
	- sp<IMemoryHeap> heap = getMemory(&offset)
	- void* const base = heap->base()
	- return static_cast<char*>(base) + offset
	}
- size_t size() 
- ssize_t offset()
- getMemory //获取指针,由MemoryBase:BnMemory,BpMemory实现
}

MemoryDealer{
  //实际内存空间
- sp<IMemoryHeap> mHeap = new MemoryHeapBase(size, flags, name){
	- const size_t pagesize = getpagesize()
	- int fd = ashmem_create_region(name, size)
	- mapfd(fd, size){
		-  void* base = (uint8_t*)mmap(0, size,fd)
		- mBase = base //设置base	
		}
	}@MemoryHeapBase.cpp
  //空间管理类
- SimpleBestFitAllocator* mAllocator = new SimpleBestFitAllocator(size){
	- chunk_t* node = new chunk_t(0,mHeapSize/32)
	- mList.insertHead(node)
	}
}@MemoryDealer.cpp

client->heap()->allocate(size)@Track.cpp-->allocate{
- const ssize_t offset = allocator()->allocate(size)
	-->mAllocator->allocate-->SimpleBestFitAllocator::allocate-->
	alloc{
       	  //遍历mList,找到最小的满足大小的chunk_t
	- chunk_t* cur = mList.head() 
	- chunk_t* free_chunk = cur
	  //将chunk_t分割为请求的大小
 	- chunk_t* split = new chunk_t(free_chunk->start, extra),mList.insertBefore(free_chunk, split) //为了对齐分割
	- chunk_t* split = new chunk_t(),mList.insertAfter(free_chunk, split) //剩下的空间分割
	- return (free_chunk->start)*kMemoryAlign //返回偏移位置
	}
- sp<IMemory> memory = new Allocation(this, heap(),offset,size){
	- MemoryBase(heap, offset, size){
		- mHeap = heap
		}
	- mDealer(dealer)
	}
- return memory
}@MemoryDealer.cpp


RecordThread::start-->AudioSystem::startInput@AudioFlinger.cpp

//读取数据
AudioFlinger::RecordThread::threadLoop{
- 
- activeTrack->getNextBuffer(&activeTrack->mSink){//获取buffer
	- mServerProxy->obtainBuffer
	- 
	}@Tracks.cpp
- mInput->stream->read(mInput->stream,mRsmpInBuffer) //读取数据，hw->read start_input
- activeTrack->mRecordBufferConverter->convert //重采样,将数据拷贝到客户端buffer中
}@Threads.cpp

//重采样，拷贝hal层数据到client
AudioFlinger::RecordThread::RecordBufferConverter::convert-->provider->getNextBuffer
-->AudioFlinger::RecordThread::ResamplerBufferProvider::getNextBuffer


//回调设置参数
setParameters(const String8& keyValuePairssetParameters(audio_io_handle_t ioHandle, keyValuePairs)@AudioSystem.cpp-->
setParameters(audio_io_handle_t ioHandle, const String8& keyValuePairs){
  //设置全局参数
- if (ioHandle == AUDIO_IO_HANDLE_NONE) {
	- audio_hw_device_t *dev = mAudioHwDevs.valueAt(i)->hwDevice()
	- dev->set_parameters(dev, keyValuePairs.string())-->adev_set_parameters@audio_hw.c//设置到hal
	- return
	}
 //设置io中参数
- thread->setParameters-->MixerThread::checkForNewParameters_l-->mOutput->stream->common.set_parameters@Threads.cpp
	-->out_set_parameters@audio_hw_hal.cpp-->setParameters@AudioHardware.cpp
}@AudioFlinger.cpp



frameworks/av/services/audioflinger/AudioFlinger.cpp
frameworks/av/services/audioflinger/AudioHwDevice.cpp
frameworks/av/services/audioflinger/AudioStreamOut.cpp
frameworks/av/services/audioflinger/Threads.cpp
frameworks/av/services/audioflinger/Tracks.cpp
frameworks/native/libs/binder/MemoryDealer.cpp
frameworks/native/libs/binder/MemoryHeapBase.cpp
frameworks/native/libs/binder/IMemory.cpp

/***********************************************
 android10

*/

//AudioTrack
sp<IAudioTrack> AudioFlinger::createTrack(const CreateTrackInput& input,
               CreateTrackOutput& output,status_t *status){
- audio_attributes_t localAttr = input.attr
- output.outputId = AUDIO_IO_HANDLE_NONE
- AudioSystem::getOutputForAttr(&localAttr, &output.outputId, sessionId, &streamType,...)
- 
}@AudioFlinger.cpp


//AudioRecord
sp<media::IAudioRecord> AudioFlinger::createRecord(const CreateRecordInput& input,
               CreateRecordOutput& output, status_t *status){

}AudioFlinger.cpp

//AudioPolicy中getInputForAttr打开
AudioFlinger::openInput(audio_module_handle_t module,audio_io_handle_t *input...)--
AudioFlinger::openInput_l(audio_module_handle_t module,audio_io_handle_t *input,audio_config_t *config,
       audio_devices_t devices,const String8& address, audio_source_t source,audio_input_flags_t flags,
       audio_devices_t outputDevice,const String8& outputDeviceAddress){
- AudioHwDevice *inHwDev = findSuitableHwDev_l(module, devices)
- *input = nextUniqueId(AUDIO_UNIQUE_ID_USE_INPUT)
- sp<DeviceHalInterface> inHwHal = inHwDev->hwDevice()
  //hal,调用到open_input_stream
- inHwHal->openInputStream(*input, devices, &halconfig, flags, address.string(), source...)
- AudioStreamIn *inputStream = new AudioStreamIn(inHwDev, inStream, flags)
- if ((flags & AUDIO_INPUT_FLAG_MMAP_NOIRQ) != 0) {
	- sp<MmapCaptureThread> thread = new MmapCaptureThread(this, *input,inHwDev, inputStream...)
	- mMmapThreads.add(*input, thread)
	return thread
  }else{
	- sp<RecordThread> thread = new RecordThread(this, inputStream, *input,...)
	- mRecordThreads.add(*input, thread)
	- return thread
  }
}@AudioFlinger.cpp

frameworks/av/services/audioflinger/AudioFlinger.cpp

/************
  device接口
*/


/************
  stream接口
*/


frameworks/av/services/audioflinger/AudioStreamOut.h
frameworks/av/include/media/audiohal/StreamHalInterface.h
