/*audioTrack通过audioFlinger进行操作

AUDIO_OUTPUT_FLAG_DIRECT	表示音频流直接输出到音频设备，不需要软件混音，一般用于 HDMI 设备声音输出
AUDIO_OUTPUT_FLAG_PRIMARY	表示音频流需要输出到主输出设备，一般用于铃声类声音
AUDIO_OUTPUT_FLAG_FAST	表示音频流需要快速输出到音频设备，一般用于按键音、游戏背景音等对时延要求高的场景
AUDIO_OUTPUT_FLAG_DEEP_BUFFER	表示音频流输出可以接受较大的时延，一般用于音乐、视频播放等对时延要求不高的场景
AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD	表示音频流没有经过软件解码，需要输出到硬件解码器，由硬件解码器进行解码
 
*/


//new AudioTrack
AudioTrack@AudioTrack.java-->native_setup-->android_media_AudioTrack_setup(
	JNIEnv *env, jobject thiz, jobject weak_this, jobject jaa,
        jintArray jSampleRate, jint channelPositionMask, jint channelIndexMask,
        jint audioFormat, jint buffSizeInBytes, jint memoryMode, jintArray jSession,
        jlong nativeAudioTrack, jboolean offload) 
{
- new AudioTrack()
- switch (memoryMode) {	//MODE_STREAM模式没有共享内存，MODE_STATIC(只写一次数据)使用共享内存
	- MODE_STREAM:lpTrack->set
	- MODE_STATIC:lpTrack->set
	}
	
}@android_media_AudioTrack.cpp


AudioTrack::AudioTrack(
        audio_stream_type_t streamType,
        uint32_t sampleRate,
        audio_format_t format,
        audio_channel_mask_t channelMask,
        size_t frameCount,
        audio_output_flags_t flags,
        callback_t cbf,
        void* user,
        int32_t notificationFrames,
        audio_session_t sessionId,
        transfer_type transferType,
        const audio_offload_info_t *offloadInfo,
        uid_t uid,
        pid_t pid,
        const audio_attributes_t* pAttributes,
        bool doNotReconnect,
        float maxRequiredSpeed)-->set(sharedBuffer){
- 检查参数，获取参数
- 获取output，AudioSystem::getOutput-->aps->getOutput
- 设置采样率，格式，channel
- 若有回调函数，创建mAudioTrackThread，new AudioTrackThread->run
- 创建，createTrack_l{
	- 获取flinger，AudioSystem::get_audio_flinger
	- 获取各种参数，AudioSystem::getxxxx(output, streamType, &xxxx)
	- 创建mAudioTrack，audioFlinger->createTrack //audioFlinger端返回一个TrackHandle
	- sp<IMemory> mCblkMemory = track->getCblk() //返回mCblkMemory
	- mCblk = iMemPointer //audioFlinger端的回调
	- mProxy = new AudioTrackClientProxy(cblk, buffers/*audioFlinger端创建的buffer*/
	}
- 赋值流类型，mStreamType = streamType
}@AudioTrack.cpp

//android8.0
AudioTrack::set(
        audio_stream_type_t streamType,
        uint32_t sampleRate,
        audio_format_t format,
        audio_channel_mask_t channelMask,
        size_t frameCount,
        audio_output_flags_t flags,
        callback_t cbf,
        void* user,
        int32_t notificationFrames,
        const sp<IMemory>& sharedBuffer/*为空*/){
- mCbf = cbf
- mUserData = user //传入回调
- if(cbf!=NULL){
	  //用于处理播放数据
	- mAudioTrackThread = new AudioTrackThread(*this, threadCanCallJava){
		- mReceiver(receiver/*AudioTrack*/)
		- mPaused(true)
		- mPausedInt(false)
		}
	- mAudioTrackThread->run("AudioTrack", ANDROID_PRIORITY_AUDIO)
	}
- createTrack_l{
	- audio_config_t config = AUDIO_CONFIG_INITIALIZER
	- AudioSystem::getOutputForAttr(attr, &output, mSessionId, &streamType, mClientUid,&config)
	- sp<IAudioTrack> track = audioFlinger->createTrack(streamType,mSampleRate,mFormat,mChannelMask)
	  //audioFlinger端track信息
	- sp<IMemory> iMem = track->getCblk()
	- void *iMemPointer = iMem->pointer()
	- mAudioTrack = track
	- audio_track_cblk_t* mCblk = cblk = static_cast<audio_track_cblk_t*>(iMemPointer)
	  //应用没有提供共享内存
	- if (mSharedBuffer == 0){
		-mProxy = new AudioTrackClientProxy(cblk, buffers, frameCount, mFrameSize)
		}
	}
}

//设置音量,设置到共享内存的mVolumeLR。服务端通过getVolumeLR获取音量
setVolume(float gain)-->setStereoVolume-->native_setVolume@AudioTrack.java-->android_media_AudioTrack_set_volume
@android_media_AudioTrack.cpp-->setVolume-->mProxy->setVolumeLR@AudioTrack.cpp
mCblk->mVolumeLR = volumeLR@AudioTrackShared.h

//设置outputdevice
AudioTrack::setOutputDevice

//play
play@AudioTrack.java-->native_start-->android_media_AudioTrack_start-->
lpTrack->start@android_media_AudioTrack.cpp-->start-->mAudioTrack->start@AudioTrack.cpp
-->AudioFlinger::TrackHandle::start@AudioFlinger.cpp-->mTrack->start@Tracks.cpp-->
start-->playbackThread->addTrack_l@Track.cpp-->AudioSystem::startOutput@Threads.cpp

start{
- 设置状态，mState
- 设置播放位置，mNewPosition
- 开始线程mAudioTrackThread，若为空则创建androidSetThreadPriority
- mAudioTrack->start@AudioTrack.cpp-->TrackHandle.start-->mTrack->start@Tracks.cpp-->
	
}@AudioTrack.cpp

//stop
stop@AudioTrack.java-->native_stop-->android_media_AudioTrack_stop
lpTrack->stop@android_media_AudioTrack.cpp-->stop@AudioTrack.cpp

stop{
- mAudioTrack->stop@AudioTrack.cpp-->(服务端Track)mTrack->stop@TrackHandle-->stop
	-->设置状态mState = STOPPED@Track.cpp
}@AudioTrack.cpp

//write
write(byte[] audioData, int offsetInBytes, int sizeInBytes)@AudioTrack.java-->
native_write_byte-->android_media_AudioTrack_writeArray
-->writeToTrack{
- if (track->sharedBuffer() == 0) {//mSharedBuffer为空走这里
	- track->write(data)
  }else{
	- memcpy(track->sharedBuffer()->pointer(), data)
  }	
}@android_media_AudioTrack.cpp

/*通过AudioTrackClientProxy proxy获取buffer
*/
AudioTrack::write(const void* buffer, size_t userSize, bool blocking){
- 获取buffer，obtainBuffer-->obtainBuffer(Buffer*,timespec)-->obtainBuffer(Buffer* audioBuffer, const struct timespec *requested){
	- 若服务对象dead，重建AudioTrack，restoreTrack_l
	  //通过代理从获取buffer，包含帧数，内存空间信息
	- proxy->obtainBuffer-->ClientProxy::obtainBuffer
	- audioBuffer->size = buffer.mFrameCount * mFrameSize
	- audioBuffer->raw = buffer.mRaw
	}
- 拷贝数据，memcpy(audioBuffer.i8, buffer)
- releaseBuffer-->mProxy->releaseBuffer
}@AudioTrack.cpp

//回调通知AudioTrack.java
set->mAudioTrackThread->runAudioTrackThread::threadLoop-->
processAudioBuffer{
  //获取锁后，获取mCblk->mFlags
- mLock.lock()
- int32_t flags = android_atomic_and(~(CBLK_UNDERRUN | CBLK_LOOP_CYCLE | CBLK_LOOP_FINAL | CBLK_BUFFER_END), &mCblk->mFlags)
- 
}@AudioTrack.cpp

frameworks/base/media/java/android/media/AudioTrack.java
frameworks/base/core/jni/android_media_AudioTrack.cpp
frameworks/av/media/libmedia/AudioTrack.cpp
frameworks/av/services/audioflinger/Tracks.cpp
frameworks/av/services/audioflinger/FastMixer.cpp
frameworks/av/services/audioflinger/AudioMixer.cpp
/**********
 android10
*/

//无参数
AudioTrack::AudioTrack()
    : mStatus(NO_INIT),
      mState(STATE_STOPPED),
      mPreviousPriority(ANDROID_PRIORITY_NORMAL),
      mPreviousSchedulingGroup(SP_DEFAULT),
      mPausedPosition(0),
      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE),
      mRoutedDeviceId(AUDIO_PORT_HANDLE_NONE)
{
    mAttributes.content_type = AUDIO_CONTENT_TYPE_UNKNOWN;
    mAttributes.usage = AUDIO_USAGE_UNKNOWN;
    mAttributes.flags = 0x0;
    strcpy(mAttributes.tags, "");
}

status_t AudioTrack::set(
        audio_stream_type_t streamType,
        uint32_t sampleRate,
        audio_format_t format,
        audio_channel_mask_t channelMask,
        size_t frameCount,
        audio_output_flags_t flags,
        callback_t cbf,
        void* user,
        int32_t notificationFrames,
        const sp<IMemory>& sharedBuffer,
        bool threadCanCallJava,
        audio_session_t sessionId,
        transfer_type transferType,
        const audio_offload_info_t *offloadInfo,
        uid_t uid,
        pid_t pid,
        const audio_attributes_t* pAttributes,
        bool doNotReconnect,
        float maxRequiredSpeed,
        audio_port_handle_t selectedDeviceId)
{
- mSessionId = sessionId
- mSharedBuffer
- mStreamType = streamType
- mFormat = format
- mChannelMask = channelMask
- mChannelCount = channelCount
- mSampleRate = sampleRate
- myPid = getpid()
  //cbf回调通知可以写入更多数据
- mCbf = cbf
- mAudioTrackThread = new AudioTrackThread(*this)
- mAudioTrackThread->run("AudioTrack", ANDROID_PRIORITY_AUDIO, 0 /*stack*/)
  //创建audioFlinger端Track
- createTrack_l(){
	- sp<IAudioFlinger>& audioFlinger = AudioSystem::get_audio_flinger()
	  //要设置的参数
	- IAudioFlinger::CreateTrackInput input
	- input.config.sample_rate = mSampleRate
	- input.config.channel_mask = mChannelMask
	  //获取的结果
	- IAudioFlinger::CreateTrackOutput output
	- sp<IAudioTrack> track = audioFlinger->createTrack(input,output,&status)
	  //
	- sp<IMemory> iMem = track->getCblk()
	- void *iMemPointer = iMem->pointer()
	- mAudioTrack = track
	- mCblkMemory = iMem
	- audio_track_cblk_t* cblk = static_cast<audio_track_cblk_t*>(iMemPointer)
	- mCblk = cblk
	- void* buffers = cblk + 1	//这块内存结构 cblk + buffer
	- mProxy = new AudioTrackClientProxy(cblk, buffers, mFrameCount, mFrameSize)
	}
}@AudioTrack.cpp

frameworks/base/core/jni/android_media_AudioTrack.cpp
frameworks/av/media/libaudioclient/AudioTrack.cpp


