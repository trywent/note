/************************* client
 decoder 解码数据

*/
NuPlayer::Decoder::Decoder(const sp<AMessage> &notify,
        const sp<Source> &source,
        pid_t pid,
        uid_t uid,
        const sp<Renderer> &renderer,
        const sp<Surface> &surface,
        const sp<CCDecoder> &ccDecoder):
  mSurface(surface)
  mSource(source)
  mRenderer(renderer)
  mCCDecoder(ccDecoder)
  mComponentName("decoder"){
- mCodecLooper = new ALooper
- mCodecLooper->setName("NPDecoder-CL")
- mCodecLooper->start(false, false, ANDROID_PRIORITY_AUDIO)
}

//初始化codec. player.start时
instantiateDecoder-->(*decoder)->configure(format)@NuPlayer-->configure@NuPlayerDecoderBase.cpp
-->onConfigure{
 //获取mime类型,判断时audio还是video
- format->findString("mime", &mime)
- mIsAudio = !strncasecmp("audio/", mime.c_str(), 6)
- mIsVideoAVC = !strcasecmp(MEDIA_MIMETYPE_VIDEO_AVC, mime.c_str())
 //codec
- mCodec = MediaCodec::CreateByType(mCodecLooper, mime.c_str(), false /* encoder */)
- mCodec->configure(format,mSurface) //surface
- sp<AMessage> reply = new AMessage(kWhatCodecNotify, this)
- mCodec->setCallback(reply)
- mCodec->start()
}@NuPlayerDecoder.cpp



onInputBufferFetched-->queueInputBuffer


onInputBufferAvailable-->msg->post()@MediaCodec.cpp-->
onMessageReceived(kWhatCodecNotify){
- msg->findInt32("callbackID", &cbID)
  switch(cbID)
- MediaCodec::CB_INPUT_AVAILABLE:{
	- msg->findInt32("index", &index)
	- handleAnInputBuffer(index)
	}@MediaCodec.cpp
}@NuPlayerDecoder.cpp

NuPlayer::Decoder::handleAnInputBuffer(size_t index){
- 
- onRequestInputBuffers@NuPlayerDecoderBase.cpp-->doRequestBuffers-->fetchInputData@NuPlayerDecoder.cpp
	-->mSource->dequeueAccessUnit@GenericSource.cpp
}@NuPlayerDecoder.cpp


/*mediaCodec

*/
struct MediaCodec : public AHandler

MediaCodec::CreateByType(const sp<ALooper> &looper, const AString &mime, bool encoder){
- sp<MediaCodec> codec = new MediaCodec(looper){
	- mLooper(looper)
	}
- codec->init(mime, true /* nameIsType */, encoder)
}@MediaCodec.cpp

MediaCodec::init(const AString &name, bool nameIsType, bool encoder){
- mResourceManagerService->init()
- mCodec = GetCodecBase(name, nameIsType){
	- nameIsType,return new ACodec
	- "android.filter.",return new MediaFilter
	}
  //设置消息处理函数
- mLooper->registerHandler(this)
}@MediaCodec.cpp

frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDecoderBase.cpp
frameworks/av/media/libstagefright/MediaCodec.cpp


/**************************codecService
  open MAX兼容解码器

  非安全解码器和软件编码器位于编解码器进程中。
  安全解码器和硬件编码器位于 mediaserver（未变更）中
*/

//media.codec Service
service mediacodec /vendor/bin/hw/android.hardware.media.omx@1.0-service@android.hardware.media.omx@1.0-service.rc-->
main{
//treble
- omxStore = new implementation::OmxStore
- omxStore->registerAsService()
- omx = new implementation::Omx()
- omx->registerAsService()
//非treble
- MediaCodecService::instantiate()
}@main_codecservice.cpp


//加载用户自定义硬件解码，加载软解
new Omx()-->new OMXMaster(){
- 初始化mProcessName
- addVendorPlugin-->addPlugin("libstagefrighthw.so"){
	- dlopen(libname)
	- createOMXPlugin = dlsym("createOMXPlugin")
	- addPlugin(createOMXPlugin()){
		- mPlugins.push_back(plugin)
		- plugin->enumerateComponents //遍历plugin中component
		- mPluginByComponentName.add //保存component
		}
	}
- addPlugin(new SoftOMXPlugin) //加入软解
}OMXMaster.cpp


Omx::allocateNode(name,observer,_hidl_cb/*omxNode*/){
- instance = new OMXNodeInstance
- OMXMaster::makeComponentInstance(name,handle) //获取codec的handle
- instance->setHandle(handle)
- _hidl_cb(toStatus(OK), new TWOmxNode(instance))
}@Omx.cpp


OMXMaster::makeComponentInstance(name){
- index = mPluginByComponentName.indexOfKey(name) 
- plugin = mPluginByComponentName.valueAt(index)//根据name获取pluging(硬解,软解)
- plugin->makeComponentInstance(name,callback,compoment){//创建component(decoder)
	- makeComponentInstance{//硬解
	- 
	}
	- makeComponentInstance{//软解
	- dlopen(libName),创建库名并打开//"libstagefright_soft_"
	- createSoftOMXComponent = dlsym(createSoftOMXComponent) //查找函数
	- codec = createSoftOMXComponent(name,callback,compoment) //创建codec
	- codec->initCheck
	}	
	}
- mPluginByInstance.add(*component, plugin)
}@OMXMaster.cpp

//client
OMXClient::connect{
//treble
- connectTreble-->IOmx::getService(name)
//非treble
- connectLegacy-->getService("media.codec")
}@OMXClient.cpp


/*CCDecode

Closed Caption(CC)，意思就是隐藏的带有解释意味的字幕（CAPTION）(描述当前画面的字母,供听力障碍者)

*/




frameworks/av/services/mediacodec/main_codecservice.cpp
frameworks/av/media/libstagefright/OMXClient.cpp
frameworks/av/media/libstagefright/omx/1.0/Omx.cpp
frameworks/av/media/libstagefright/omx/OMXMaster.cpp


//hardware中的omx没有使用
hardware/interfaces/media/omx/1.0/IOmx.hal
hardware/interfaces/media/omx/1.0/android.hardware.media.omx@1.0_genc++/gen/android/hardware/media/omx/1.0/OmxAll.cpp
