/**************************codecService
  open MAX兼容解码器

  非安全解码器和软件编码器位于编解码器进程中。
  安全解码器和硬件编码器位于 mediaserver（未变更）中
*/
ServiceName "media.codec"
service mediacodec /vendor/bin/hw/android.hardware.media.omx@1.0-service @android.hardware.media.omx@1.0-service.rc-->
main{
//treble
- omxStore = new implementation::OmxStore //moxStore
- omxStore->registerAsService()  
- omx = new implementation::Omx() //omx
- omx->registerAsService()
//非treble
- MediaCodecService::instantiate()
}@main_codecservice.cpp


/*加载xml中声明的解码器
  
 media_codecs.xml{
	- setting属性
	- 编码器，码率，分辨率的限制
	- 解码器，码率，分辨率的限制
	}
 media_codecs_performance.xml{
	- 编解码器的帧率限制
	}
*/

defaultSearchDirs[] = {"/odm/etc", "/vendor/etc", "/etc", nullptr};
defaultMainXmlName = "media_codecs.xml";
defaultPerformanceXmlName ="media_codecs_performance.xml";
defaultProfilingResultsXmlPath ="/data/misc/media/media_codecs_profiling_results.xml"

OmxStore("default",defaultSearchDirs,defaultMainXmlName,defaultPerformanceXmlName,defaultProfilingResultsXmlPath){
- MediaCodecsXmlParser parser(searchDirs,mainXmlName,performanceXmlName,profilingResultsXmlPath){
	- findFileInDirs(searchDirs, mainXmlName, &path){
		- parseTopLevelXMLFile(path.c_str(), false)
		}
	- findFileInDirs(searchDirs, performanceXmlName, &path){
		- parseTopLevelXMLFile(path.c_str(), false)
		}
	}@MediaCodecXmlParser.cpp
  //加载设置 MediaCode的setting
- auto& serviceAttributeMap = parser.getServiceAttributeMap()
- for (const auto& attributePair : serviceAttributeMap) {
	- ServiceAttribute attribute
	- attribute.key = attributePair.first
	- mServiceAttributeList[i] = std::move(attribute)
	}
  //加载编解码器
- const auto& roleMap = parser.getRoleMap
- for (const auto& rolePair : roleMap) {
	- RoleInfo role
	- role.role = rolePair.first
	- role.type = rolePair.second.type
	- mRoleList[i] = std::move(role)
	}
}@OmxStore.cpp

//加载用户自定义硬件解码，加载软解
new Omx()-->new OMXMaster(){
- 初始化mProcessName
  //硬解
- addVendorPlugin-->addPlugin("libstagefrighthw.so"){
	- dlopen(libname)
	- createOMXPlugin = dlsym("createOMXPlugin")
	- addPlugin(createOMXPlugin())
  //加入软解
- addPlugin(new SoftOMXPlugin) 
}@OMXMaster.cpp


//加入plugin(解码库合集，软解，硬解)
addPlugin(createOMXPlugin()){
- mPlugins.push_back(plugin)
  //遍历plugin中component，获取名字
- OMX_U32 index = 0，char name[128]
- while(plugin->enumerateComponents(name,index++)){
	- String8 name8(name)
	- mPluginByComponentName.add(name8,pulgin) 	//保存解码器名字到mPluginByComponentName
	}
}@OMXMaster.cpp

//创建解码，并返回到client
Omx::allocateNode(name,observer,_hidl_cb/*omxNode*/){
- sp<OMXNodeInstance> instance = new OMXNodeInstance(this, new LWOmxObserver(observer), name.c_str()){
	- mOwner(owner)
	- mObserver(observer) //LWOmxObserver(observer)
	}@OMXNodeInstance.cpp
- OMXMaster::makeComponentInstance(name,&OMXNodeInstance::kCallbacks,instance.get(),handle) //获取codec的handle
  //设置回调
- instance->setHandle(handle){
	- mHandle = handle
	- mDispatcher = new CallbackDispatcher(this)
	}@OMXNodeInstance.cpp
- _hidl_cb(toStatus(OK), new TWOmxNode(instance))	//将codec返回给client
}@Omx.cpp

OMXMaster::makeComponentInstance(const char *name,const OMX_CALLBACKTYPE *callbacks,
        OMX_PTR appData,OMX_COMPONENTTYPE **component){
- index = mPluginByComponentName.indexOfKey(name) 
- plugin = mPluginByComponentName.valueAt(index)			//根据name获取pluging(硬解,软解)
- plugin->makeComponentInstance(name,callback,appData,compoment){	//创建component(decoder) 
	- makeComponentInstance@SprdOMXPlugin.cpp			//硬解 
 	- makeComponentInstance(const char *name,const OMX_CALLBACKTYPE *callbacks,OMX_PTR appData,OMX_COMPONENTTYPE **component)//软解
	}
- mPluginByInstance.add(*component, plugin)
}@OMXMaster.cpp

//
Omx::createInputSurface(createInputSurface_cb _hidl_cb) {
- sp<::android::IGraphicBufferProducer> bufferProducer
- sp<GraphicBufferSource> graphicBufferSource = new GraphicBufferSource(){
	- BufferQueue::createBufferQueue(&mProducer, &mConsumer)
	}@GraphicBufferSource.cpp
- graphicBufferSource->initCheck()
- bufferProducer = graphicBufferSource->getIGraphicBufferProducer()
}@Omx.cpp


frameworks/av/media/libstagefright/omx/1.0/OmxStore.cpp
frameworks/av/media/libstagefright/xmlparser/MediaCodecsXmlParser.cpp
/**************************
 软解Component
 SoftOMXComponent
 
*/
//解码器状态回调
typedef struct OMX_CALLBACKTYPE
{
OMX_ERRORTYPE (*EventHandler)(OMX_IN OMX_HANDLETYPE hComponent,OMX_IN OMX_PTR pAppData,OMX_IN OMX_EVENTTYPE eEvent,
        	  OMX_IN OMX_U32 nData1,OMX_IN OMX_U32 nData2,OMX_IN OMX_PTR pEventData);
OMX_ERRORTYPE (*EmptyBufferDone)(OMX_IN OMX_HANDLETYPE hComponent,OMX_IN OMX_PTR pAppData,OMX_IN OMX_BUFFERHEADERTYPE* pBuffer);
OMX_ERRORTYPE (*FillBufferDone)(OMX_OUT OMX_HANDLETYPE hComponent,OMX_OUT OMX_PTR pAppData,OMX_OUT OMX_BUFFERHEADERTYPE* pBuffer);
} OMX_CALLBACKTYPE;@OMX_Core.h


//通知Client端解码状态
OMX_CALLBACKTYPE OMXNodeInstance::kCallbacks = {
    &OnEvent, &OnEmptyBufferDone, &OnFillBufferDone
}@OMXNodeInstance.cpp

//创建软解component,codec。解码器在不同的库中libstagefright_soft_
OMXMaster::makeComponentInstance-->plugin->makeComponentInstance(name,callback,appData,compoment)@OMXMaster.cpp-->
makeComponentInstance(const char *name,const OMX_CALLBACKTYPE *callbacks,OMX_PTR appData,OMX_COMPONENTTYPE **component){
- dlopen(libName),					 //打开"libstagefright_soft_"
- createSoftOMXComponent = dlsym(createSoftOMXComponent) //查找函数
- codec = createSoftOMXComponent(name,callback,compoment)//创建codec
- codec->initCheck
}@SoftOMXPlugin.cpp

//通知解码事件
notify-->(*mCallbacks->EventHandler)(mComponent)@SoftOMXComponent.cpp
EventHandler-->OnEvent{

}@OMXNodeInstance.cpp

//通知需要数据
notifyEmptyBufferDone-->(*mCallbacks->EmptyBufferDone)(mComponent)@SoftOMXComponent.cpp
EmptyBufferDone-->OnEmptyBufferDone(OMX_IN OMX_HANDLETYPE /* hComponent */,
        OMX_IN OMX_PTR pAppData,OMX_IN OMX_BUFFERHEADERTYPE* pBuffer){
- OMXNodeInstance *instance = static_cast<OMXNodeInstance *>(pAppData)
- omx_message msg
- msg.type = omx_message::EMPTY_BUFFER_DONE
- instance->mDispatcher->post(msg){
	- mQueue.push_back(msg)
	- mQueueChanged.signal()
	}
}@OMXNodeInstance.cpp

//通知解码完成
notifyFillBufferDone-->(*mCallbacks->FillBufferDone)(mComponent)@SoftOMXComponent.cpp
FillBufferDone-->OnFillBufferDone{

}@OMXNodeInstance.cpp



frameworks/av/media/libstagefright/omx/SoftOMXComponent.cpp
/**************************
 硬解Component

 
*/

makeComponentInstance@SprdOMXPlugin.cpp



/*CCDecode

Closed Caption(CC)，意思就是隐藏的带有解释意味的字幕（CAPTION）(描述当前画面的字母,供听力障碍者,枪声，虫鸣鸟叫，对白)

*/




frameworks/av/services/mediacodec/main_codecservice.cpp
frameworks/av/media/libstagefright/OMXClient.cpp
frameworks/native/headers/media_plugin/media/openmax/OMX_Core.h
frameworks/av/media/libstagefright/omx/1.0/Omx.cpp
frameworks/av/media/libstagefright/omx/OMXMaster.cpp
frameworks/av/media/libstagefright/xmlparser/MediaCodecsXmlParser.cpp
frameworks/av/media/libstagefright/omx/OMXNodeInstance.cpp
//hardware中的omx没有使用
hardware/interfaces/media/omx/1.0/IOmx.hal
hardware/interfaces/media/omx/1.0/android.hardware.media.omx@1.0_genc++/gen/android/hardware/media/omx/1.0/OmxAll.cpp

/**************************
 client
 
 IOMX --- omx服务
 WOmx 封装IOMX
 IOMXNode --- omx component相当解码器

*/

//创建解码器
UninitializedState::onAllocateComponent{
- OMXClient client
- client.connect(owners[matchIndex].c_str(), &trebleFlag)	//根据解码器名字
- sp<IOMX> omx = client.interface()				//omx服务端接口
- sp<IOMXNode> omxNode
- omx->allocateNode(componentName.c_str(), observer, &omxNode)
}@ACodec.cpp

//client连接到omx
OMXClient::connect{
//treble
- connectTreble{
	- sp<IOmx> tOmx = IOmx::getService(name)
	- sp<IOMX> mOMX = new utils::LWOmx(tOmx){
		- mBase(tOmx)
		}@WOmx.cpp
	}
//非treble
- connectLegacy
}@OMXClient.cpp


//创建服务端node,observer接收创建TWOmxNode
LWOmx::allocateNode(const char *name, const sp<IOMXObserver> &observer,sp<IOMXNode> *omxNode)-->
mBase->allocateNode(name, new TWOmxObserver(observer),[&fnStatus, omxNode](Status status, sp<IOmxNode> const& node) {
                fnStatus = toStatusT(status);*omxNode = new LWOmxNode(node); }))@WOmx.cpp-->
Omx::allocateNode(name,observer,_hidl_cb/*omxNode*/)@Omx.cpp

//
LWOmx::createInputSurface(
        sp<::android::IGraphicBufferProducer>* bufferProducer,
        sp<::android::IGraphicBufferSource>* bufferSource)

frameworks/av/media/libstagefright/OMXClient.cpp
frameworks/av/media/libmedia/omx/1.0/WOmx.cpp
