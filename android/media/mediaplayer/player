/*************************
  NULPlayerDriver

*/
enum player_type {
    STAGEFRIGHT_PLAYER = 3,
    NU_PLAYER = 4, //默认播放器
    TEST_PLAYER = 5,
};

enum State {
        STATE_IDLE,
        STATE_SET_DATASOURCE_PENDING,
        STATE_UNPREPARED,
        STATE_PREPARING,
        STATE_PREPARED,
        STATE_RUNNING,
        STATE_PAUSED,
        STATE_RESET_IN_PROGRESS,
        STATE_STOPPED,                  // equivalent to PAUSED
        STATE_STOPPED_AND_PREPARING,    // equivalent to PAUSED, but seeking
        STATE_STOPPED_AND_PREPARED,     // equivalent to PAUSED, but seek complete
}

//开始线程 "NuPlayerDriver Looper"
createPlayer(NU_PLAYER)-->factory->createPlayer@MediaPlayerService.cpp-->
createPlayer-->new NuPlayerDriver@MediaPlayerFactory.cpp-->
NuPlayerDriver{
- mLooper(new ALooper)
- mPlayer(new NuPlayer(pid))
- mLooper->start
- mLooper->registerHandler(mPlayer)
- mPlayer->setDriver(this)
}@NuPlayerDriver.cpp

//设置文件源
NuPlayerDriver::setDataSource(int fd, int64_t offset, int64_t length) {
- mState = STATE_SET_DATASOURCE_PENDING
- mPlayer->setDataSourceAsync(fd, offset, length)
  //等待player设置完成
- mCondition.wait(mLock)
}@NuPlayerDriver.cpp
//设置http源
NuPlayerDriver::setDataSource(const sp<IMediaHTTPService> &httpService, const char *url){
- mState = STATE_SET_DATASOURCE_PENDING
- mPlayer->setDataSourceAsync(httpService, url, headers)
  //等待player设置完成
- mCondition.wait(mLock)
}@NuPlayerDriver.cpp

notifySetDataSourceCompleted{
- CHECK_EQ(mState, STATE_SET_DATASOURCE_PENDING) //检查状态是否是STATE_SET_DATASOURCE_PENDING
- mState = (err == OK) ? STATE_UNPREPARED : STATE_IDLE
- mCondition.broadcast()
}

//perpare
NuPlayerDriver::prepare()-->prepare_l

/*NULPlayer:  mDriver为NuPlayerDriver

*/
struct NuPlayer: public AHandler{
  //文件数据
- Source mSource
  //图像
- Surface mSurface
  //声音
- AudioSink mAudioSink
  //解码
- DecoderBase mVideoDecoder
- DecoderBase mAudioDecoder
- CCDecoder mCCDecoder
  //渲染
- Renderer mRenderer
}@NuPlayer.cpp

NuPlayer::setDriver(const wp<NuPlayerDriver> &driver)-->mDriver = driver@NuPlayer.cpp

//消息处理,通知
onMessageReceived(const sp<AMessage> &msg){
  switch (msg->what())
  //设置mSource
- kWhatSetDataSource:{	 
	- msg->findObject("source", &obj)
	- mSource = static_cast<Source *>(obj.get()
	 //通知driver设置完成
	- mDriver.promote()->notifySetDataSourceCompleted(err)
	}
- kWhatSourceNotify:{
   	- onSourceNotify(msg)
	}
- kWhatScanSources:{
	- instantiateDecoder(false,&mVideoDecoder)
	- instantiateDecoder(true,&mAudioDecoder)
	}
}

onSourceNotify(const sp<AMessage> &msg){
- msg->findInt32("what", &what)
  switch (what)
  //创建安全解码器
- Source::kWhatInstantiateSecureDecoders:
	- onInstantiateSecureDecoders{
		- (mSourceFlags & Source::FLAG_SECURE)
		- instantiateDecoder(false,&mVideoDecoder)
		- instantiateDecoder(true,&mAudioDecoder)
	}
- Source::kWhatPrepared 
- Source::kWhatBufferingUpdate:{
	- notifyListener(MEDIA_BUFFERING_UPDATE, percentage
	}
}

1
/*设置mSource
  
*/
setDataSourceAsync(int fd, int64_t offset, int64_t length){
- msg = new AMessage(kWhatSetDataSource)
- notify = new AMessage(kWhatSourceNotify)
- source = new new GenericSource(notify, mUIDValid, mUID)
- source->setDataSource(fd, offset, length)
  //通知设置完成
- msg->post(source)-->onMessageReceived(kWhatSetDataSource)-->mSource
}@NuPlayer.cpp

//设置mAudioSink
MediaPlayerService::Client::setDataSource_pre-->setAudioSink-->
onMessageReceived(kWhatSetAudioSink)-->mAudioSink@@NuPlayer.cpp

//设置mSurface
MediaPlayerService::Client::setVideoSurfaceTexture-->NuPlayerDriver::setVideoSurfaceTexture
mPlayer->setVideoSurfaceTextureAsync-->NuPlayer::setVideoSurfaceTextureAsync-->
onMessageReceived(kWhatSetVideoSurface){
- !mStarted状态,performSetSurface(surface){
	- mSurface
	- setVideoScalingMode
	}
- 否则延迟操作{
	- mDeferredActions.push_back(FlushDecoderAction)
	- mDeferredActions.push_back(SetSurfaceAction(surface))
	- mDeferredActions.push_back(SimpleAction(&performScanSources))
	- mDeferredActions.push_back(ResumeDecoderAction)
	- processDeferredActions
	}
}

2
/* prepare

*/
prepareAsync@NuPlayerDriver.cpp-->prepareAsync-->(new AMessage(kWhatPrepare, this))->post()
-->mSource->prepareAsync()@NuPlayer.cpp

3 
/*start:
  mSource读取数据
  创建解码器
*/
start-->new AMessage(kWhatStart)->post-->onMessageReceived(kWhatStart)-->
onStart(int64_t startPositionUs, MediaPlayerSeekMode mode){
- mSource->start()
- mRenderer = new Renderer(mAudioSink)
- mRendererLooper = new ALooper
- mRendererLooper->start(false, false, ANDROID_PRIORITY_AUDIO)
- mRendererLooper->registerHandler(mRenderer)
- mVideoDecoder->setRenderer(mRenderer)
- mAudioDecoder->setRenderer(mRenderer)
  //初始化解码器decoder
- postScanSources-->new AMessage(kWhatScanSources).post()-->onMessageReceived{
	- instantiateDecoder(false, &mVideoDecoder)
	- instantiateDecoder(true,&mAudioDecoder)
	}
}@NuPlayer.cpp

//初始化mVideoDecoder,mAudioDecoder
instantiateDecoder(bool audio,&decoder){
- sp<AMessage> format = mSource->getFormat(audio) //获取格式
  //创建字符解码
- !audio{
	- ccNotify = new AMessage(kWhatClosedCaptionNotify)
	- 获取mime
	- mCCDecoder = new CCDecoder(ccNotify)
	- format->setInt32 //设置secure,protected,operatiion-rate
	}
  //音频解码器
- audio{
	- notify = new AMessage(kWhatAudioNotify)
	- *decoder = new Decoder(notify, mSource, mPID, mUID, mRenderer)
	}
  //视频解码器
- !audio{
	- notify = new AMessage(kWhatVideoNotify)
	- *decoder =new Decoder(notify, mSource, mPID, mUID, mRenderer, mSurface, mCCDecoder)
	}
- (*decoder)->init()
- (*decoder)->configure(format)  //初始化
}@NuPlayer.cpp


performDecoderFlush-->flushDecoder

frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp
frameworks/av/media/libmediaplayerservice/MediaPlayerFactory.cpp
frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
/*************************
 source 提供数据
 获取源文件track信息,创建track
 读取track数据
 通知player

*/
GenericSource::GenericSource:
 Source(notify)
 mUID(uid)
 mFd(-1){
- mBufferingMonitor = new BufferingMonitor(notify)
- resetDataSource
}

setDataSourceAsync@NuPlayer.cpp-->setDataSource(int fd, int64_t offset, int64_t length){
- mFd = dup(fd)
- mOffset = offset
}@GenericSource.cpp

1//prepare
prepareAsync@NuPlayerDriver.cpp-->prepareAsync-->mSource->prepareAsync@NuPlayer.cpp-->
prepareAsync{
- mLooper = new ALooper;
- mLooper->setName("generic")
- mLooper->start()
- mLooper->registerHandler(this)
 //
- sp<AMessage> msg = new AMessage(kWhatPrepareAsync, this)
- msg->post()
}

onMessageReceived(kWhatPrepareAsync)-->onPrepareAsync{
- mUri{
	- 检查uri是否"http"
	- mDataSource = DataSource::CreateFromURI
	}
- mFd{
	- mediaExService(getService(String16("media.extractor")) //获取extractor
	- sp<IDataSource> source = mediaExService->makeIDataSource(mFd, mOffset, mLength)
	- mDataSource = DataSource::CreateFromIDataSource(source)
	}
  //创建extrator,获取数据
- initFromDataSource
- finishPrepareAsync{
	- startSources{
		- mAudioTrack.mSource->start()
		- mVideoTrack.mSource->start()
		}
	- mBufferingMonitor->prepare(mCachedSource, mDurationUs, mBitrate,mIsStreaming)
	- mBufferingMonitorLooper = new ALooper
	- mBufferingMonitorLooper->start()
	- mBufferingMonitorLooper->registerHandler(mBufferingMonitor) //监听buffer?
	- mBufferingMonitor->restartPollBuffering()
	}
}@GenericSource.cpp


//获取音频视频数据信息,初始化音视频track
initFromDataSource{
- sp<IMediaExtractor> extractor = MediaExtractor::Create(mDataSource, NULL)
- mFileMeta = extractor->getMetaData()
  //时长
- mFileMeta->findInt64(kKeyDuration, &duration)
  //从文件中获取音频,视频
- size_t numtracks = extractor->countTracks()
- size_t maxBuffers = 1
- for (size_t i = 0; i < numtracks; ++i){
	- sp<IMediaSource> track = extractor->getTrack(i)
	- sp<MetaData> meta = extractor->getTrackMetaData(i
	- meta->findCString(kKeyMIMEType, &mime) //获取数据类型.音频,视频
	- if (!strncasecmp(mime, "audio/", 6)) {
		- mAudioTrack.mIndex = i
		- mAudioTrack.mSource = track
		- mAudioTrack.mPackets = new AnotherPacketSource(mAudioTrack.mSource->getFormat())
		}
	- if (!strncasecmp(mime, "video/", 6)) {
		- mVideoTrack.mIndex = i
		- mVideoTrack.mSource = track
		- mVideoTrack.mPackets = new AnotherPacketSource(mVideoTrack.mSource->getFormat())
		}
	- mSources.push(track)
	}
}@GenericSource.cpp


2//start 开始读取音视频数据
start{
- postReadBuffer(MEDIA_TRACK_TYPE_AUDIO){
	- sp<AMessage> msg = new AMessage(kWhatReadBuffer, this)
	- msg->setInt32("trackType", trackType)
	- msg->post()-->onMessageReceived-->onReadBuffer
	}
- postReadBuffer(MEDIA_TRACK_TYPE_VIDEO)
- (new AMessage(kWhatStart, this))->post()-->onMessageReceived-->
}

onReadBuffer(const sp<AMessage>& msg){
- msg->findInt32("trackType", &tmpType)
- media_track_type trackType = (media_track_type)tmpType
  //读取数据
- readBuffer(trackType){
- Track *track
- switch (trackType) {
        - MEDIA_TRACK_TYPE_VIDEO
            track = &mVideoTrack
            maxBuffers = 8  // too large of a number may influence seeks
        - MEDIA_TRACK_TYPE_AUDIO
            track = &mAudioTrack
            maxBuffers = 64
        - MEDIA_TRACK_TYPE_SUBTITLE
            track = &mSubtitleTrack
        - MEDIA_TRACK_TYPE_TIMEDTEXT
            track = &mTimedTextTrack
	}
- for (size_t numBuffers = 0; numBuffers < maxBuffers; ) {
	 //读取maxBuffers数据
	- Vector<MediaBuffer *> mediaBuffers
	- MediaBuffer *mbuf = NULL
	- track->mSource->read(&mbuf, &options)
	- mediaBuffers.push_back(mbuf)
	 //遍历查找所有buffer中kKeyTime'time'
	- MediaBuffer *mbuf = mediaBuffers[id]
	- mbuf->meta_data()->findInt64(kKeyTime, &timeUs)
	- mBufferingMonitor->updateQueuedTime(true/false /* isAudio */, timeUs) //根据音视频数据时间
	 //加入队列
	- sp<ABuffer> buffer = mediaBufferToABuffer(mbuf, trackType)
	- track->mPackets->queueAccessUnit(buffer)
	}
}
}@GenericSource.cpp


dequeueAccessUnit-->postReadBuffer


frameworks/av/media/libmediaplayerservice/nuplayer/GenericSource.cpp

