/*****************************************
 audiopolicy

 setprop log.tag.APM_AudioPolicyManager V
*/

//解析xml中attach的设备，加入下面变量
mAvailableOutputDevices
mAvailableInputDevices


AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)
	: AudioPolicyManager(clientInterface, false /*forTesting*/){
- mConfig(mHwModulesAll, mAvailableOutputDevices, mAvailableInputDevices, mDefaultOutputDevice)
- loadConfig()-->deserializeAudioPolicyXmlConfig(getConfig()){
	- std::vector<const char*> fileNames
	- fileNames.push_back(AUDIO_POLICY_XML_CONFIG_FILE_NAME)//"audio_policy_configuration.xml"
	- for (const char* fileName : fileNames) {		//遍历kConfigLocationList中文件夹加载。"/odm/etc", "/vendor/etc", "/system/etc"
		- snprintf(audioPolicyXmlConfigFile, sizeof(audioPolicyXmlConfigFile), "%s/%s", kConfigLocationList[i], fileName)
		- deserializeAudioPolicyFile(audioPolicyXmlConfigFile, &config)
		}
	}
- initialize(){
	- audio_policy::EngineInstance *engineInstance = audio_policy::EngineInstance::getInstance()
	- mEngine = engineInstance->queryInterface<AudioPolicyManagerInterface>()
	- mEngine->setObserver(this)
	- 
	}
}


/************
 engine

*/
//使用 engineconfigurable
USE_CONFIGURABLE_AUDIO_POLICY := 1@ums512_1h10/ums512_1h10_Base.mk

ifeq ($(USE_CONFIGURABLE_AUDIO_POLICY), 1)
LOCAL_SHARED_LIBRARIES += libaudiopolicyengineconfigurable
else
LOCAL_SHARED_LIBRARIES += libaudiopolicyenginedefault
endif 
@audiopolicy/managerdefault/Android.mk


//根据属性获取输出设备
Engine::getOutputDevicesForAttributes(const audio_attributes_t &attributes,
        const sp<DeviceDescriptor> &preferredDevice, bool fromCache, bool ignoreFM){
- product_strategy_t strategy = getProductStrategyForAttributes(attributes)		//获取策略
- DeviceVector availableOutputDevices = getApmObserver()->getAvailableOutputDevices()	//可用的输出设备
- SwAudioOutputCollection &outputs = getApmObserver()->getOutputs()			//
- sp<DeviceDescriptor> device = findPreferredDevice(outputs, strategy, availableOutputDevices){
	- 
	}
  //没找到
- getDevicesForProductStrategy(strategy,ignoreFM)
}@Engine.cpp



/************
 output

 设置output时会设置流对应的设备。会影响通路
*/

AudioPolicyManager::setOutputDevices(const sp<SwAudioOutputDescriptor>& outputDesc,const DeviceVector &devices,
                     bool force, int delayMs, audio_patch_handle_t *patchHandle,bool requiresMuteCheck){
  //设置output对应的设备
- DeviceVector filteredDevices = outputDesc->filterSupportedDevices(devices)
- DeviceVector prevDevices = outputDesc->devices()
- outputDesc->setDevices(filteredDevices)
  //设置路径
- PatchBuilder patchBuilder
- patchBuilder.addSource(outputDesc)
- installPatch(__func__, patchHandle, outputDesc.get(), patchBuilder.patch(), delayMs)
- applyStreamVolumes(outputDesc, filteredDevices.types(), delayMs)
}



/************
 input

*/
