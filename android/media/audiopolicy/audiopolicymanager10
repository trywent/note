/*****************************************
 audiopolicy

 setprop log.tag.APM_AudioPolicyManager V
*/

//解析xml中attach的设备，加入下面变量
mAvailableOutputDevices
mAvailableInputDevices


AudioPolicyManager::AudioPolicyManager(AudioPolicyClientInterface *clientInterface)
	: AudioPolicyManager(clientInterface, false /*forTesting*/){
- mConfig(mHwModulesAll, mAvailableOutputDevices, mAvailableInputDevices, mDefaultOutputDevice)
- loadConfig()-->deserializeAudioPolicyXmlConfig(getConfig()){
	- std::vector<const char*> fileNames
	- fileNames.push_back(AUDIO_POLICY_XML_CONFIG_FILE_NAME)//"audio_policy_configuration.xml"
	- for (const char* fileName : fileNames) {		//遍历kConfigLocationList中文件夹加载。"/odm/etc", "/vendor/etc", "/system/etc"
		- snprintf(audioPolicyXmlConfigFile, sizeof(audioPolicyXmlConfigFile), "%s/%s", kConfigLocationList[i], fileName)
		- deserializeAudioPolicyFile(audioPolicyXmlConfigFile, &config)
		}
	}
- initialize(){
	- audio_policy::EngineInstance *engineInstance = audio_policy::EngineInstance::getInstance()
	- mEngine = engineInstance->queryInterface<AudioPolicyManagerInterface>()
	- mEngine->setObserver(this)
	- 
	}
}

//设置设备连接状态，耳机，hdmi
setDeviceConnectionState(audio_devices_t device,audio_policy_dev_state_t state,...)-->
setDeviceConnectionStateInt(audio_devices_t deviceType,audio_policy_dev_state_t state,
	const char *device_address,const char *device_name, audio_format_t encodedFormat){
- sp<DeviceDescriptor> device = mHwModules.getDeviceDescriptor(deviceType, device_address, device_name,..)
  //处理output
- if (audio_is_output_device(deviceType)) {
	- AUDIO_POLICY_DEVICE_STATE_AVAILABLE{
		- broadcastDeviceConnectionState(device, state){	//设置到hal,param
			- AudioParameter param(device->address())
			- mpClientInterface->setParameters(AUDIO_IO_HANDLE_NONE, param.toString())
			}
		}
	- AUDIO_POLICY_DEVICE_STATE_UNAVAILABLE{
		- broadcastDeviceConnectionState(device, state)
		- AvailableOutputDevices.remove(device)
		}
	- setEngineDeviceConnectionState(device, state)
	}
  //处理input
- if (audio_is_input_device(deviceType)) {

	}
}@AudioPolicyManager.java


/************
 engine

*/
//使用 engineconfigurable
USE_CONFIGURABLE_AUDIO_POLICY := 1@ums512_1h10/ums512_1h10_Base.mk

ifeq ($(USE_CONFIGURABLE_AUDIO_POLICY), 1)
LOCAL_SHARED_LIBRARIES += libaudiopolicyengineconfigurable
else
LOCAL_SHARED_LIBRARIES += libaudiopolicyenginedefault
endif 
@audiopolicy/managerdefault/Android.mk




Engine(){
  //policy参数
- mPolicyParameterMgr(new ParameterManagerWrapper()){
	  //"/vendor/etc/parameter-framework/ParameterFrameworkConfigurationPolicy.xml"
	- mPfwConnector = new CParameterMgrPlatformConnector(mPolicyPfwVendorConfFileName)
	}
  //
- status_t loadResult = loadAudioPolicyEngineConfig()
  	//加载策略
	- loadProductStrategies = [](auto& strategyConfigs, auto& productStrategies, auto& volumeGroups) {
		- sp<ProductStrategy> strategy = new ProductStrategy(strategyConfig.name)
		- strategy->addAttributes({group.stream, iter->second->getId(), attr})
		- productStrategies[strategyId] = strategy
	}
 	 //加载音量
	- loadVolumeGroups = [](auto &volumeConfigs, auto &volumeGroups) {

 	}
  	//加载"/vendor/etc/audio_policy_engine_configuration.xml"
	- auto result = engineConfig::parse()
	- loadVolumeGroups(result.parsedConfig->volumeGroups, mVolumeGroups)
	- loadProductStrategies(result.parsedConfig->productStrategies, mProductStrategies,mVolumeGroups)
	- mProductStrategies.initialize()
	}@EngineBase.cpp
}@Engine.cpp


//根据属性获取输出设备
Engine::getOutputDevicesForAttributes(const audio_attributes_t &attributes,
        const sp<DeviceDescriptor> &preferredDevice, bool fromCache, bool ignoreFM){
- product_strategy_t strategy = getProductStrategyForAttributes(attributes)		//获取策略
- DeviceVector availableOutputDevices = getApmObserver()->getAvailableOutputDevices()	//可用的输出设备
- SwAudioOutputCollection &outputs = getApmObserver()->getOutputs()			//
- sp<DeviceDescriptor> device = findPreferredDevice(outputs, strategy, availableOutputDevices){
	- 
	}
  //没找到
- getDevicesForProductStrategy(strategy,ignoreFM){
	-
	- devices = productStrategies.getDeviceTypesForProductStrategy(ps)
	- return availableOutputDevices.getDevicesFromTypeMask(devices)
	}
}@Engine.cpp

//获取流的strategy
EngineBase::getProductStrategyForStream(audio_stream_type_t stream){
- ProductStrategyMap::getProductStrategyForStream(audio_stream_type_t stream){
	- for (const auto &iter : *this) {
		- return iter.second->getId()
		}
	}
}@EngineBase.cpp


frameworks/av/services/audiopolicy/engineconfigurable/src/Engine.cpp
frameworks/av/services/audiopolicy/engine/common/src/EngineBase.cpp
/************
 strategy 参数

*/
ParameterManagerWrapper::start(){
- mPfwConnector->start(error)
}




frameworks/av/services/audiopolicy/engineconfigurable/wrapper/ParameterManagerWrapper.cpp
frameworks/av/services/audiopolicy/engine/common/src/ProductStrategy.cpp
/************
 output

 设置output时会设置流对应的设备。会影响通路
*/

AudioPolicyManager::setOutputDevices(const sp<SwAudioOutputDescriptor>& outputDesc,const DeviceVector &devices,
                     bool force, int delayMs, audio_patch_handle_t *patchHandle,bool requiresMuteCheck){
  //设置output对应的设备
- DeviceVector filteredDevices = outputDesc->filterSupportedDevices(devices)
- DeviceVector prevDevices = outputDesc->devices()
- outputDesc->setDevices(filteredDevices)
  //设置路径
- PatchBuilder patchBuilder
- patchBuilder.addSource(outputDesc)
- installPatch(__func__, patchHandle, outputDesc.get(), patchBuilder.patch(), delayMs)
- applyStreamVolumes(outputDesc, filteredDevices.types(), delayMs)
}



/************
 input

*/
