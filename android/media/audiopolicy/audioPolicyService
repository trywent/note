/***************************************************
 audiopolicyService接口和数据结构

  调用流程
 上层应用--- audioPolicyManager(AudioPolicyInterfaceImpl) --- AudioPolicyClient --- audioPolicyService

*/
//接口 在AudioPolicyInterfaceImpl.cpp中实现。AudioSystem调用
{
setPhoneState(audio_mode_t state)
audio_io_handle_t getOutput(audio_stream_type_t stream)					//output接口
status_t getOutputForAttr(const audio_attributes_t *attr,audio_io_handle_t *output,...)
status_t startOutput(audio_port_handle_t portId);
status_t stopOutput(audio_port_handle_t portId)
void releaseOutput(audio_port_handle_t portId)
status_t getInputForAttr(const audio_attributes_t *attr,audio_io_handle_t *input...)	//input接口
status_t startInput(audio_port_handle_t portId);
status_t stopInput(audio_port_handle_t portId);
void releaseInput(audio_port_handle_t portId)
status_t setStreamVolumeIndex(audio_stream_type_tstream,intindex,audio_devices_t device)//音量接口
status_t getStreamVolumeIndex(audio_stream_type_t stream,int *index,audio_devices_t device)
status_t registerEffect(const effect_descriptor_t *desc,audio_io_handle_t io,...)	//音效
status_t unregisterEffect(int id)
status_t setEffectEnabled(int id, bool enabled)
audio_devices_t getDevicesForStream(audio_stream_type_t stream)				//获取设备device
status_t listAudioPorts(audio_port_role_t role,audio_port_type_t type,...)		//ports
status_t getAudioPort(struct audio_port *port)
status_t createAudioPatch(const struct audio_patch *patch,audio_patch_handle_t *handle..)//patch
status_t releaseAudioPatch(audio_patch_handle_t handle, uid_t uid);
status_t listAudioPatches(unsigned int *num_patches,struct audio_patch *patches,unsigned int *generation)
status_t setAudioPortConfig(const struct audio_port_config *config)
status_t startAudioSource(const struct audio_port_config *source...)			//源
status_t stopAudioSource(audio_port_handle_t portId)
}@frameworks/av/services/audiopolicy/service/AudioPolicyInterfaceImpl.cpp



frameworks/av/services/audiopolicy/AudioPolicyInterface.h
frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.h
frameworks/av/media/libaudioclient/include/media/IAudioPolicyService.h
/***************************************************
 AudioPolicyService	
 AudioPolicyManager	audioSystem操作的接口
 AudioPolicyClient	操作audioflinger的接口

 没有policyhal

 audio_policy_configuration.xml中声明所有的支持模块,根据这些配置加载对应的库文件
 9853：vendor/sprd/modules/audio/normal/newapm/O.x/AudioPolicyManagerSPRD.cpp

*/
//AudioPolicyService启动
main(int argc __unused, char **argv)-->AudioPolicyService::instantiate()@main_audioserver.cpp-->
AudioPolicyService::onFirstRef{
- mTonePlaybackThread = new AudioCommandThread        
- mAudioCommandThread = new AudioCommandThread		// start audio commands thread
- mOutputCommandThread = new AudioCommandThread		// start output activity command thread
- mAudioPolicyClient = new AudioPolicyClient(this)	// 操作audioflinger的接口
- mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient)
  //音效
- mAudioPolicyEffects = new AudioPolicyEffects
}



//更新权限。前台app,语音助手允许录音
updateUidStates-->updateUidStates_l{

}@AudioPolicyService.cpp

/***************
 接口 AudioPolicyInterfaceImpl --- AudioPolicyManager
*/

AudioPolicyService::getOutput(audio_stream_type_t stream)-->mAudioPolicyManager->getOutput(stream)
@AudioPolicyInterfaceImpl.cpp


AudioPolicyService::getOutputForAttr(audio_attributes_t *attr,audio_io_handle_t *output,....){
- mAudioPolicyManager->getOutputForAttr(attr, output, session, stream, uid,...)
- sp <AudioPlaybackClient> client = new AudioPlaybackClient(*attr, *output, uid, pid, session, *selectedDeviceId, *stream)
- mAudioPlaybackClients.add(*portId, client)
}@AudioPolicyInterfaceImpl.cpp


/***************
  audiopolicyservice 命令处理线程AudioCommandThread
*/

//命令处理
AudioPolicyService::AudioCommandThread::threadLoop(){
- sp<AudioCommand> command = mAudioCommands[0]
- switch (command->mCommand) {
	- START_TONE{
		- 		
		}
	- 
	- CREATE_AUDIO_PATCH: {
		- command->mStatus = af->createAudioPatch(&data->mPatch, &data->mHandle)
		}
	}
}@AudioPolicyService.cpp

//发送命令
AudioPolicyService::AudioPolicyClient::createAudioPatch-->
mAudioPolicyService->clientCreateAudioPatch@AudioPolicyClientImpl.cpp-->AudioPolicyService::clientCreateAudioPatch-->
AudioCommandThread::createAudioPatchCommand(const struct audio_patch *patch,audio_patch_handle_t *handle,int delayMs){

}@AudioPolicyService.cpp


/***************
 output

*/

openOutput-->af->openOutput@AudioPolicyClientImpl.cpp-->AudioFlinger::openOutput

//android8.0
AudioPolicyManager::getOutputForAttr(&output,selectedDeviceId){
- strategy = getStrategyForAttr			//获取策略
- device = getDeviceForStrategy(strategy)	//获取设备
- getOutputForDevice(device,stream){
	- 遍历mOutputs查找合适的output返回
	- outputDesc = new SwAudioOutputDescriptor(profile)
	- outputDesc->mDevice = device
	- mpClientInterface->openOutput(output)
	- addOutput(output, outputDesc)
	}
}


/***************
 input
  
   1,获取设备，打开input

E AudioRecord: start() status -38
I AudioRecord: start error  mClientUid:0 mClientPid:3510  mSessionId:249 app name:/oem/bin/blink 
I AudioRecord: start  mClientUid:0 mClientPid:3510  mSessionId:249 app name:/oem/bin/blink 
W APM_AudioPolicyManager: startInput(30) failed: other input already starte

*/
AudioRecord-->set-->openRecord_l-->AudioSystem::getInputForAttr(&mAttributes, &input)@AudioRecore.cpp-->
getInputForAttr(const audio_attributes_t *attr,audio_io_handle_t *input)-->aps->getInputForAttr@AudioSystem.cpp-->
getInputForAttr(const audio_attributes_t *attr,audio_io_handle_t *input,audio_session_t session,uid_t uid,const audio_config_base_t *config,
	audio_input_flags_t flags,audio_port_handle_t *selectedDeviceId,input_type_t *inputType){
- audio_source_t inputSource = attr->source
  //特殊情况mmap
- if ((flags & AUDIO_INPUT_FLAG_MMAP_NOIRQ) == AUDIO_INPUT_FLAG_MMAP_NOIRQ &&
            *input != AUDIO_IO_HANDLE_NONE){}
- halInputSource = inputSource
  //获取设备
- if (inputSource == AUDIO_SOURCE_REMOTE_SUBMIX){
	- *inputType = API_INPUT_MIX_EXT_POLICY_REROUTE
	- device = AUDIO_DEVICE_IN_REMOTE_SUBMIX
  }else{
	- device = getDeviceAndMixForInputSource(inputSource, &policyMix){
		- 若存在则返回，audio_devices_t selectedDeviceFromMix = mPolicyMixes.getDeviceAndMixForInputSource(inputSource)
		- getDeviceForInputSource(inputSource)
		}
	- *inputType = API_INPUT_LEGACY
  }
  //根据inputsource获取input
- *input = getInputForDevice(device, address, session, uid, inputSource)
- inputDevices = mAvailableInputDevices.getDevicesFromType(device)
}@AudioPolicyManager.cpp


//获取audio_port_handle_t input
AudioPolicyManager::getInputForDevice(audio_devices_t device,String8 address,audio_session_t session,uid_t uid,
        audio_source_t inputSource,uint32_t samplingRate,audio_format_t format,audio_channel_mask_t channelMask,
        audio_input_flags_t flags,AudioMix *policyMix){
- audio_source_t halInputSource = inputSource
- isSoundTrigger = false
  //唤醒词
- if (inputSource == AUDIO_SOURCE_HOTWORD) {
	 //session已经存在
	- input = mSoundTriggerSessions.valueFor(session)
	- isSoundTrigger = true
	 //session不存在
	- halInputSource = AUDIO_SOURCE_VOICE_RECOGNITION
	}
  //查找对应的profile
- uint32_t profileSamplingRate = samplingRate
- audio_format_t profileFormat = format
- sp<IOProfile> profile = getInputProfile(device, address,profileSamplingRate){
	 //遍历mHwModules，遍历mInputProfiles
	-  if (profile->isCompatibleProfile(device, address, samplingRate,&samplingRate, format)
		return profile
	}
  //创建session
- sp<AudioSession> audioSession = new AudioSession(session,inputSource,format,samplingRate)
  //初始化config
- audio_config_t config = AUDIO_CONFIG_INITIALIZER
- config.sample_rate = profileSamplingRate
  //打开hal层input
- status = mpClientInterface->openInput(profile->getModuleHandle(),&input,&config,&device)
  //创建AudioInputDescriptor,保存到mInputs中
- sp<AudioInputDescriptor> inputDesc = new AudioInputDescriptor(profile)
- inputDesc->addAudioSession(session, audioSession)
- addInput(input, inputDesc)-->mInputs.add(input, inputDesc)
}@AudioPolicyManager.cpp


//根据inputSource获取对应的设备
getDeviceForInputSource(audio_source_t inputSource){
- 从mInputRoutes中查找相同，return route->mDeviceDescriptor->type()
- mEngine->getDeviceForInputSource(inputSource){
	- return device
	}@Engine.cpp
}@AudioPolicyManager.cpp



//开始录音
start@AudioRecord.cpp-->RecordThread::start@Threads.cpp-->startInput@AudioSystem.cpp-->
startInput(audio_io_handle_t input,audio_session_t session){
- 
}@AudioPolicyMananger.cpp

//停止录音
stop-->mAudioRecord->stop@AudioRecord.cpp-->RecordHandle::stop-->stop_nonvirtual@Track.cpp-->
AudioFlinger::RecordThread::RecordTrack::stop-->AudioSystem::stopInput-->aps->stopInput-->
stopInput(audio_io_handle_t input,audio_session_t session){
- 
}@AudioPolicyMananger.cpp


frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
frameworks/av/services/audioflinger/AudioPolicyService.cpp
frameworks/av/services/audiopolicy/service/AudioPolicyClientImpl.cpp
frameworks/av/services/audiopolicy/common/managerdefinitions/src/Serializer.cpp
frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp




