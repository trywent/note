/*

 audio_policy_configuration.xml中声明所有的支持模块,根据这些配置加载对应的库文件

 9853：vendor/sprd/modules/audio/normal/newapm/O.x/AudioPolicyManagerSPRD.cpp
*/


//结构
module{
//mixport
- IOProfile{
	- name
	- role //sink source
	- flags //AUDIO_OUTPUT_FLAG_PRIMARY AUDIO_OUTPUT_FLAG_DEEP_BUFFER
	- AudioProfile
	}
//deviceport
- DeviceDescriptor {
	- name
	- type
	- role //sink source
	- AudioProfile
	}
//route
- AudioRoute{
    - AudioPort sink //只有一个sink. 将route加入sink
    - AudioPort source  //多个source 将route加入source
   }
}

//实例结构
HwModule{
//mixport
- mOutputProfiles
- mInputProfiles
//deviceport
- DeviceVector mDeclaredDevices
//route
- AudioRouteVector mRoutes 
//包含mixport ,deviceport
- AudioPortVector mPorts  
}

AudioOutputDescriptor //output


AudioPolicyService::onFirstRef{
- mTonePlaybackThread = new AudioCommandThread        
- mAudioCommandThread = new AudioCommandThread// start audio commands thread
- mOutputCommandThread = new AudioCommandThread// start output activity command thread
- mAudioPolicyClient = new AudioPolicyClient(this) //audioflinger的封装
- mAudioPolicyManager = createAudioPolicyManager(mAudioPolicyClient);
- mAudioPolicyEffects = new AudioPolicyEffects
}

createAudioPolicyManager-->
AudioPolicyManager(AudioPolicyClientInterface *clientInterface){
- mpClientInterface = clientInterface //audioflinger
- mVolumeCurves = new VolumeCurvesCollection()
- AudioPolicyConfig config(mHwModules, mAvailableOutputDevices, mAvailableInputDevices)
  //解析加载odm/vendor/system下"audio_policy_configuration.xml"
- deserializeAudioPolicyXmlConfig(config)-->serializer.deserialize{
	- 
	}
  /* 使用 enginedefault    
   */
- engineInstance = audio_policy::EngineInstance::getInstance
- mEngine = engineInstance->queryInterface<AudioPolicyManagerInterface>()-->Engine{
	- ManagerInterfaceImpl mManagerInterface(this)
	}
- mEngine->initializeVolumeCurves //初始化音量
  //根据mHwModules的名字,加载prmary,usb,a2dp库
- 遍历,mHwModules{
	- mHwModules[i]->mHandle = mpClientInterface->loadHwModule(name)--> 
	  AudioPolicyService::AudioPolicyClient::loadHwModule-->af->loadHwModule(name)
	  //将当前可用的设备关联到audiohw
	- 遍历,mOutputProfiles{
		- profileType = outProfile->getSupportedDeviceForType(outputDeviceTypes)//找对对应存在的设备
		- outputDesc = new SwAudioOutputDescriptor(outprofile) //创建当前设备的outputStream
		- outputDesc->mDevice = profileType
		- mpClientInterface->openOutput(&output)
		- mAvailableOutputDevices[index]->attach //设置attached设备可用状态
		- addOutput(output, outputDesc) //保存到mOutputs
		- setOutputDevice //设置route,patch
		}
	- 遍历,mInputProfiles{
		- sp<AudioInputDescriptor> inputDesc = new AudioInputDescriptor
		- mpClientInterface->openInput
		- devDesc->attach(mHwModules[i])/devDesc->importAudioPort //设置attached设备可用状态
		}
	}
- 
}@AudioPolicyManager.cpp

//解析xml。初始化profile
deserializeAudioPolicyXmlConfig(config)-->serializer.deserialize{
- deserializeCollection<ModuleTraits>(modules,&config)-->ModuleTraits::deserialize{
	//IOProfile mixport 
	- deserializeCollection<MixPortTraits>(mixPorts)
	- module->setProfiles(mixPorts)-->addProfile{
		- addOutputProfile //outputProflie/inputProfile
		- addInputProfile
		}
	 //DeviceDescriptor devicePorts 
	- deserializeCollection<DevicePortTraits>(devicePorts)
	- module->setDeclaredDevices(devicePorts)
	 //AudioRoute route
	- deserializeCollection<RouteTraits>(routes){
		- sink->addRoute/source->addRoute //保存route到sink,source中
		}
	- module->setRoutes(routes){
		- mRoutes = routes
		- refreshSupportedDevices-->stream->setSupportedDevices // 设置profile支持的设备
		}
	 //attachedDevices 已连接设备(DeviceDescriptor)
	- config->addAvailableDevice-->mAvailableOutputDevices.add/mAvailableInputDevices.add 
	- config->setDefaultOutputDevice-->mDefaultOutputDevices //"defaultOutputDevice"
	}
- config.setHwModules(modules) //加入module
- deserializeCollection<VolumeTraits>(volumes, &config)
- config.setVolumes(volumes) //volume配置
}@Serializer.cpp

//audioService接口实现
AudioPolicyService::{
- setDeviceConnectionState
- createAudioPatch
}AudioPolicyInterfaceImpl.cpp


//devices状态
AudioPolicyManager::setDeviceConnectionState-->setDeviceConnectionStateInt{
- mAvailableOutputDevices.add(devDesc)
- mAvailableInputDevices.add(devDesc)
}
=================
/* output

*/

openOutput-->af->openOutput@AudioPolicyClientImpl.cpp-->AudioFlinger::openOutput

//android8.0
AudioPolicyManager::getOutputForAttr(&output,selectedDeviceId){
- strategy = getStrategyForAttr //获取策略
- device = getDeviceForStrategy(strategy)//获取设备
- getOutputForDevice(device,stream){
	- 遍历mOutputs查找合适的output返回
	- outputDesc = new SwAudioOutputDescriptor(profile)
	- outputDesc->mDevice = device
	- mpClientInterface->openOutput(output)
	- addOutput(output, outputDesc)
	}
}


=================
/* input
  
   1,获取设备，打开input

*/
AudioRecord-->set-->openRecord_l-->AudioSystem::getInputForAttr(&mAttributes, &input)@AudioRecore.cpp-->
getInputForAttr(const audio_attributes_t *attr,audio_io_handle_t *input)-->aps->getInputForAttr@AudioSystem.cpp-->
getInputForAttr(const audio_attributes_t *attr,audio_io_handle_t *input,audio_session_t session,uid_t uid,const audio_config_base_t *config,
	audio_input_flags_t flags,audio_port_handle_t *selectedDeviceId,input_type_t *inputType){
- audio_source_t inputSource = attr->source
  //特殊情况mmap
- if ((flags & AUDIO_INPUT_FLAG_MMAP_NOIRQ) == AUDIO_INPUT_FLAG_MMAP_NOIRQ &&
            *input != AUDIO_IO_HANDLE_NONE){}
- halInputSource = inputSource
  //获取设备
- if (inputSource == AUDIO_SOURCE_REMOTE_SUBMIX){
	- *inputType = API_INPUT_MIX_EXT_POLICY_REROUTE
	- device = AUDIO_DEVICE_IN_REMOTE_SUBMIX
  }else{
	- device = getDeviceAndMixForInputSource(inputSource, &policyMix){
		- 若存在则返回，audio_devices_t selectedDeviceFromMix = mPolicyMixes.getDeviceAndMixForInputSource(inputSource)
		- getDeviceForInputSource(inputSource)
		}
	- *inputType = API_INPUT_LEGACY
  }
  //根据inputsource获取input
- *input = getInputForDevice(device, address, session, uid, inputSource)
- inputDevices = mAvailableInputDevices.getDevicesFromType(device)
}@AudioPolicyManager.cpp


//获取input
AudioPolicyManager::getInputForDevice(audio_devices_t device,String8 address,audio_session_t session,uid_t uid,
        audio_source_t inputSource,uint32_t samplingRate,audio_format_t format,audio_channel_mask_t channelMask,
        audio_input_flags_t flags,AudioMix *policyMix){
- audio_source_t halInputSource = inputSource
- isSoundTrigger = false
  //唤醒词
- if (inputSource == AUDIO_SOURCE_HOTWORD) {
	 //session已经存在
	- input = mSoundTriggerSessions.valueFor(session)
	- isSoundTrigger = true
	 //session不存在
	- halInputSource = AUDIO_SOURCE_VOICE_RECOGNITION
	}
  //查找对应的profile
- uint32_t profileSamplingRate = samplingRate
- audio_format_t profileFormat = format
- sp<IOProfile> profile = getInputProfile(device, address,profileSamplingRate){
	 //遍历mHwModules，遍历mInputProfiles
	-  if (profile->isCompatibleProfile(device, address, samplingRate,&samplingRate, format)
		return profile
	}
  //创建session
- sp<AudioSession> audioSession = new AudioSession(session,inputSource,format,samplingRate)
  //初始化config
- audio_config_t config = AUDIO_CONFIG_INITIALIZER
- config.sample_rate = profileSamplingRate
  //打开hal层input
- status = mpClientInterface->openInput(profile->getModuleHandle(),&input,&config,&device)
  //创建AudioInputDescriptor,保存到mInputs中
- sp<AudioInputDescriptor> inputDesc = new AudioInputDescriptor(profile)
- inputDesc->addAudioSession(session, audioSession)
- addInput(input, inputDesc)-->mInputs.add(input, inputDesc)
}@AudioPolicyManager.cpp


//根据inputSource获取对应的设备
getDeviceForInputSource(audio_source_t inputSource){
- 从mInputRoutes中查找相同，return route->mDeviceDescriptor->type()
- mEngine->getDeviceForInputSource(inputSource){
	- return device
	}@Engine.cpp
}@AudioPolicyManager.cpp



//开始录音
start@AudioRecord.cpp-->RecordThread::start@Threads.cpp-->startInput@AudioSystem.cpp-->
startInput{
- 
}@AudioPolicyMananger.cpp


frameworks/av/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
frameworks/av/services/audioflinger/AudioPolicyService.cpp
frameworks/av/services/audiopolicy/service/AudioPolicyClientImpl.cpp
frameworks/av/services/audiopolicy/common/managerdefinitions/src/Serializer.cpp
frameworks/av/services/audiopolicy/enginedefault/src/Engine.cpp




