/*************************************
 binder和本地调用类似:
	- 函数等待调用结束才返回
	- 支持递归回调(A-B-A)
*/

IBInder接口：不要直接实现该接口，一般继承Binder（实现了IBinder）
transact发起一个调用到IBinder,Binder.onTransact()接收一个调用.这对方法是同步的，
一个对transact()的调用不会返回，直到目标从Binder.onTransact()返回。这实际和调用本地对象
是一样的，IPC机制保证了跨进程的调用，和在当前进程调用表现是一样的。（本地方法调用也是要等待方法执行完成才
返回，跨进程调用要等待在另一个进程上被调用的方法的完成）


判断远程对象不可用：
1，The transact() method will throw a RemoteException exception if you try to call it on an IBinder whose process no longer exists.
2，The pingBinder() method can be called, and will return false if the remote process no longer exists.
3，The linkToDeath() method can be used to register a IBinder.DeathRecipient with the IBinder, which will be called when its containing process goes away.

//aidl：
xxx.aidl生成Ixxx.java
public interface Ixxx extends android.os.IInterface{
- String DESCRIPTOR ="xxx"
- public static abstract class Stub extends Binder implements Ixxx{ //本地服务
	- method实现
	- asInterface(IBinder){
		- new Ixxx.Stub.Proxy(obj/*BinderProxy*/) //创建Proxy
		}
	- onTransact-->method
	- private static class Proxy implements Ixxx{ //远程代理
		- Proxy(obj/*BinderProxy*/){
			mRemote = obj
			}
		- IBinder mRemote //远程接口
		- method-->mRemote.transact
		}
	}
- 需要实现的method
}



/*
 IBinder实现,Binder BinderProxy
*/

//本地实现
Binder implements IBinder{
- init-->android_os_Binder_init{ //初始化mObject
	- JavaBBinderHolder* jbh = new JavaBBinderHolder()
	- env->SetLongField(gBinderOffsets.mObject, (jlong)jbh)
	}
- NoImagePreloadHolder.sRegistry.registerNativeAllocation(this, mObject) //将当前对象和native关联,垃圾回收使用?
- attachInterface{
	- mOwner     //this
	- mDescriptor //一般为类名com.xxx.xxx
	}
- transact    //调用到远程
- onTransact  //处理调动
- linkToDeath(@NonNull DeathRecipient recipient) //监听remote是不是挂了
- execTransact
}@Binder.java


//远程接口
BinderProxy implements IBinder{
- pingBinder
- transact-->transactNative
}@Binder.java

register_android_os_Binder{
- int_register_android_os_Binder{
	- clazz = FindClassOrDie(env,  "android/os/Binder")
	- gBinderOffsets.mClass = MakeGlobalRefOrDie(env, clazz)
	- gBinderOffsets.mExecTransact = GetMethodIDOrDie("execTransact")
	- gBinderOffsets.mObject = GetFieldIDOrDie( "mObject")
	- RegisterMethodsOrDie(gBinderMethods) //getCallingPid 之类的方法
	}
- int_register_android_os_BinderInternal{
	- clazz = FindClassOrDie("com/android/internal/os/BinderInternal")
	- gBinderInternalOffsets.mClass
	}
- int_register_android_os_BinderProxy{
	- clazz = FindClassOrDie(env, "android/os/BinderProxy")
	- gBinderProxyOffsets.mObject =GetFieldIDOrDie("mObject")
	- RegisterMethodsOrDie(gBinderProxyMethods)//pingBinder linkToDeath 之类的方法
	}
}@android_util_Binder.cpp


//proxy发起调用
BinderProxy.transact-->transactNative@Binder.java-->
android_os_BinderProxy_transact{
- IBinder* target = (IBinder*)env->GetLongField(obj, gBinderProxyOffsets.mObject) //获取目标
- target->transact(code, *data, reply, flags)
}@android_util_Binder.cpp

//local接收调用
onTransact-->env->CallBooleanMethod(mObject, gBinderOffsets.mExecTransact)@android_util_Binder.cpp
-->execTransact-->onTransact@Binder.java

//发起调用
transact@BpBinder.cpp-->IPCThreadState::self()->transact-->
transact(int32_t handle,uint32_t code, const Parcel& data,Parcel* reply)@IPCThreadState.cpp


frameworks/base/core/java/android/os/Binder.java
frameworks/base/core/jni/android_util_Binder.cpp
frameworks/native/libs/binder/Binder.cpp
frameworks/native/include/binder/IPCThreadState.h
frameworks/native/libs/binder/IPCThreadState.cpp
frameworks/native/libs/binder/BpBinder.cpp
frameworks/native/libs/binder/Binder.cpp
/*
  paracel用于binder间传输的数据.打包成一个由基本数据类型组成的数据.另一端重新组合
*/

Parcel(int)-->init(int)@Parcel.java-->nativeCreat-->android_os_Parcel_create@android_os_parcel.cpp--new Parcel()@Parcel.cpp

//获取paracel：
obtain(obj)-->Parcel(obj)-->init(obj)@Parcel.java-->mNativePtr=obj 或赋值nativeCreate()-->
android_os_Parcel_create@android_os_Parcel.cpp


//写入Binder：
writeStrongBinder(IBinder val)@Parcel.java-->nativeWriteStrongBinder(mNativePtr, val)-->
android_os_Parcel_writeStrongBinder(jlong nativePtr, jobject object){
- Parcel* parcel = reinterpret_cast<Parcel*>(nativePtr)
- sp<IBinder>& val = ibinderForJavaObject(env, object){ //返回BBinder,BpBinder
	- Binder{
		- JavaBBinderHolder* jbh =env->GetLongField(obj, gBinderOffsets.mObject)
		- jbh->get() //返回 new JavaBBinder继承public BBinder
		}
	- BinderProxy{
		- env->GetLongField(obj, gBinderProxyOffsets.mObject) //返回BinderProxy
		}
	}
- parcel->writeStrongBinder(val/*IBinder*/)-->flatten_binder(const sp<IBinder>& binder, Parcel* out){
	- flat_binder_object obj
	- IBinder *local = binder->localBinder() //IBinder返回NULL(BpBinder),BBinder返回本身
	- !local,BpBinder{
		- BpBinder *proxy = binder->remoteBinder()
		- handle = proxy->handle()
		- obj.type = BINDER_TYPE_HANDLE
		- obj.handle = handle
		}
	- BBinder{
		- obj.type = BINDER_TYPE_BINDER
		- obj.binder = reinterpret_cast<uintptr_t>(local->getWeakRefs())
		- obj.cookie = reinterpret_cast<uintptr_t>(local)
		}
	- finish_flatten_binder(binder,obj,out) //将obj写入out
	}@Parcel.cpp
}@android_os_Parcel.cpp


//读出Binder：
reply.readStrongBinder@ServiceManagerNative.java-->nativeReadStrongBinder-->
android_os_Parcel_readStrongBinder(jlong nativePtr){
- Parcel* parcel = reinterpret_cast<Parcel*>(nativePtr)
- sp<IBinder>& val = parcel->readStrongBinder-->readNullableStrongBinder(sp<IBinder> val)
	-->unflatten_binder(ProcessState::self(), *this, val){
	- const flat_binder_object* flat = in.readObject(false)
	- BINDER_TYPE_BINDER:*val = reinterpret_cast<IBinder*>(flat->cookie)  //BBinder
	- BINDER_TYPE_HANDLE:*val = proc->getStrongProxyForHandle(flat->handle) //ProcessState创建BpBinder
	}@Parcel.cpp
- javaObjectForIBinder(val){ //创建java IBinder
	- object = env->NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor) //BinderProxy
	- env->SetLongField(object, gBinderProxyOffsets.mObject, (jlong)val.get()) //设置mObject 为BpBinder(那个handle)
	}
}@android_os_Parcel.cpp


/home/wangbo/src/jb/frameworks/base/core/java/android/os/Parcel.java
/home/wangbo/src/jb/frameworks/native/libs/binder/Parcel.cpp
/home/wangbo/src/jb/frameworks/base/core/jni/android_os_Parcel.cpp








/*************************************
  ServiceManager获取,添加服务，获取服务
*/
//serviceManager启动
service servicemanager /system/bin/servicemanager@servicemanager.rc-->
main{
- struct binder_state *bs = binder_open("/dev/binder"){
	- struct binder_state *bs
	- bs->fd = open()
	- bs->mapped = mmap(bs->fd)
 	}@binder.c
- binder_loop(bs, svcmgr_handler) //读取数据解析,回复
}@service_manager.c

binder_loop(bs, svcmgr_handler){
- binder_write(bs, BC_ENTER_LOOPER)
  //循环读取数据
- ioctl(bs->fd, BINDER_WRITE_READ) //读取信息
- binder_parse(func){
	- BR_TRANSACTION{//收到调用
		- func-->svcmgr_handler
		- binder_send_reply-->binder_write{//回复
			- struct binder_write_read bwr
			- bwr.write_size = len //设置要写入的数据
			- ioctl(bs->fd, BINDER_WRITE_READ,bwr) 
			}
		}
	- BR_REPLY //收到回复
	}
}@binder.c

svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn,struct binder_io *msg){
- uint32_t handle //
- SVC_MGR_GET_SERVICE/SVC_MGR_CHECK_SERVICE:do_find_service{ //查找服务
	- s = bio_get_string16(msg, &len)
	- handle = do_find_service(s){
		- struct svcinfo *si = find_svc(s, len)
		- return si->handle
		}
	- bio_put_ref(reply /*obj*/, handle){
		- struct flat_binder_object *obj = bio_alloc_obj
		- obj->type = BINDER_TYPE_HANDLE
		- obj->handle = handle
		}
	}
- SVC_MGR_ADD_SERVICE:{//加入服务
	- s = bio_get_string16(msg, &len) //name
	- handle = bio_get_ref(msg){ //非handle(BpBinder)时为0
		- _bio_get_obj-->bio_get(bio, sizeof(struct flat_binder_object))//struct flat_binder_object
		- (obj->type == BINDER_TYPE_HANDLE),return obj->handle
		}
	- do_add_service(handle){
		- struct svcinfo *si = find_svc
		- si->handle = handle
		- 
		}
	}
- SVC_MGR_LIST_SERVICES:svc_can_list
- bio_put_uint32(reply, 0)//回复0
}@service_manager.c

frameworks/native/cmds/servicemanager/service_manager.c
frameworks/native/cmds/servicemanager/binder.c

//获取ServiceManager：获取到一个BpBinder(0) ServiceManagerProxy
getIServiceManager-->ServiceManagerNative.asInterface(Binder.allowBlocking(BinderInternal.getContextObject())){
- Binder.allowBlocking(BinderInternal.getContextObject()){
	- BinderInternal.getContextObject-->android_os_BinderInternal_getContextObject{
		- sp<IBinder> b = ProcessState::self()->getContextObject //new BpBinder(0)
		- return javaObjectForIBinder(env, b){ //创建java IBinder对象
			- object = env->NewObject(gBinderProxyOffsets.mClass, gBinderProxyOffsets.mConstructor)
			}
		}@android_util_Binder.cpp
	- allowBlocking
	}@Binder.java
- ServiceManagerNative.asInterface(IBinder obj){
	- IServiceManager in = (IServiceManager)obj.queryLocalInterface("android.os.IServiceManager")
	- 否则,return new ServiceManagerProxy(obj)
	}@ServiceManagerNative.java
}@ServiceManager.java





//添加系统服务到serviceManager：
ServiceManager.addService(String name, IBinder service)@SystemService.java-->addService-->
getIServiceManager().addService-->ServiceManagerNative.asInterface(BinderInternal.getContextObject())
.addService@ServiceManager.java-->ServiceManagerProxy.addService(String name, IBinder service){
- Parcel data = Parcel.obtain()
- data.writeStrongBinder(service)
- mRemote.transact(ADD_SERVICE_TRANSACTION, data)
}@ServiceManagerNative.java


//再从serviceManager获取服务：
ServiceManager.getService@ContextImpl.java-->getService-->getIServiceManager().getService
@ServcieManager.java-->ServiceManagerProxy.getService(name){
- Parcel data = Parcel.obtain()
- data.writeString(name)
- mRemote.transact(GET_SERVICE_TRANSACTION, data, reply)
- IBinder binder = reply.readStrongBinder() //从parcel中读取Binder
}@ServiceManagerNative.java




//进程死亡处理：
远程代理加入监听：
BinderProxy.linkToDeath@Binder.java-->android_os_BinderProxy_linkToDeath-->target->linkToDeath
@android_util_Binder.cpp-->linkToDeath-->(保存处理对象)mObituaries->add@BpBinder.cpp

IPCThreadState::clearDeathNotification-->mOut.writeInt32(BC_CLEAR_DEATH_NOTIFICATION)

接收到远程进程死亡消息：
executeCommand(BR_DEAD_BINDER)-->proxy->sendObituary()@TPCThreadState.cpp
sendObituary-->reportOneDeath(取出处理对象，处理进程结束)-->recipient->binderDied@BpBinder.cpp





frameworks/base/core/java/android/os/ServiceManager.java
frameworks/base/core/java/android/os/ServiceManagerNative.java
frameworks/base/core/java/com/android/internal/os/BinderInternal.java
frameworks/base/core/jni/android_util_Binder.cpp
frameworks/native/libs/binder/ProcessState.cpp
frameworks/base/core/java/android/os/Binder.java
frameworks/native/libs/binder/Parcel.cpp

