//======================================service:

service像其他应用的对象一样，也运行在主进程中。也就是在进行耗时操作时，service应该运行在自己的线程中（另生成一个线程）。
IntentService 已经实现了在另一个线程中工作。

服务启动的两种方式：Started(服务要自己停止)，Bound（服务在最后一个客户unbind后销毁）
如：一个Activity调用Context.startService(Intent service),
如：组件调用bindService (Intent service, ServiceConnection conn, int flags)这种方式下，一旦组件绑定到，
服务就开始运行

实现一个Service，其中要实现的几个重要方法：
onStartCommand() 当组件调用startService时系统调用的函数
onBind()  组件绑定到service时，系统调用的函数
onCreate() 服务被创建时系统调用的函数
onDestroy() 服务被销毁时系统调用的函数

service有什么作用（好像没什么作用）：
1.告诉系统一些任务要在后台进行（不让系统杀死进程，回收资源）。 
2.提供一些功能让其他应用程序调用。对应的调用Context.bindService()

Bounded Service：
创建能被绑定的服务，其中重要的是实现onBind函数。这个函数返回一个binder对象，通过这个对象定义了编程接口，client可以用来与service交互。
发送请求，接收响应，或者执行IPC

当服务是本地服务(非IPC)，这时binder只返回本地服务即可(参考service的reference)。
当客户端与服务是进行进程间通信（IPC）时，这时的binder是实现AIDL的接口类。AIDL会自动生成一个stub接口

使用AIDL创建一个bounded service:
1. Create the .aidl file
This file defines the programming interface with method signatures.
2. Implement the interface 实现生成的stub接口（是一个binder接口）
The Android SDK tools generate an interface in the Java programming language, based on your .aidl file. This interface has an inner abstract class named Stub that extends Binder and implements methods from your AIDL interface. You must extend the Stub class and implement the methods.
3. Expose the interface to clients 实现服务的onbind函数，返回对应的binder
Implement a Service and override onBind() to return your implementation of the Stub class.

//client获得binder
服务实现onBind(返回binder)，用户d端实现onServiceConnected(接收服务返回的binder，将binder转换为服务)。

when a client (such as an activity) calls bindService() to connect to this service, the client's onServiceConnected() callback receives the mBinder instance returned by the service's onBind() method.

获得binder后要通过他获得需要的服务
 it must call Your ServiceInterface.Stub.asInterface(binder) to cast the returned parameter to YourServiceInterface type.



/*************************************
 service 
*/

//启动
bindService(Intent service, ServiceConnection conn)-->
bindServiceCommon(service,conn,mMainThread.getHandler()){
- IServiceConnection sd = mPackageInfo.getServiceDispatcher(conn){
	- ServiceDispatcher map = mServices.get(context)
	- sd = map.get(c) //先从缓存中查找,
	- sd = new ServiceDispatcher(c),map.put(c, sd)//没有则创建
	- return sd.getIServiceConnection() //返回mIServiceConnection. InnerConnection extends IServiceConnection.Stub
	}
- ActivityManager.getService().bindService(mMainThread.getApplicationThread(),service,mIServiceConnection)
}@ContextImpl.java

bindService-->mServices.bindServiceLocked@ActivityManagerService.java-->
bindServiceLocked(Intent service, IServiceConnection connection){
- ServiceLookupResult res = retrieveServiceLocked(service,)
- ServiceRecord s = res.record
- AppBindRecord b = s.retrieveAppBindingLocked 
- ConnectionRecord c = new ConnectionRecord(b) //保存connection
- ArrayList<ConnectionRecord> clist = s.connections.get(binder)
- clist.add(c)
- mServiceConnections.get(binder).add(c)
- getServiceMapLocked(s.userId).ensureNotStartingBackgroundLocked(s)-->ServiceMap.ensureNotStartingBackgroundLocked
	-->rescheduleDelayedStartsLocked{
	- 
				
	}
}@ActiveServices.java

获取IServiceConnection流程:
bindService@ContextImpl.java-->mPackageInfo（返回IServiceConnection）.getServiceDispatcher-->
new ServiceDispatcher(c, context, handler, flags)--sd.getIServiceConnection-->ServiceDispatcher.
getIServiceConnection(返回new InnerConnection)@LoadedApk.java-->



frameworks/base/core/java/android/app/ContextImpl.java
frameworks/base/core/java/android/app/LoadedApk.java
frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
frameworks/base/services/core/java/com/android/server/am/ActiveServices.java
