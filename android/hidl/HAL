/*
 Hardware Abstraction Laye(hal)提供硬件操作接口

 hardware中各个模块都编译成动态库，在使用某个模块时再加载。
*/
//hw_module_t 通过methonds获取struct hw_device_t
typedef struct hw_module_t {
    uint32_t tag;    
    uint16_t module_api_version;
    const char *id;
    const char *name;
    const char *author;
    struct hw_module_methods_t* methods;
    void* dso;
    uint32_t reserved[32-7];
} hw_module_t;

//打开。获取struct hw_device_t
typedef struct hw_module_methods_t {
    int (*open)(const struct hw_module_t* module, const char* id,
            struct hw_device_t** device);
} hw_module_methods_t;

//通过struct hw_device_t 获取 xxx_hw_device
typedef struct hw_device_t {
    uint32_t tag;  
    uint32_t version;
    struct hw_module_t* module;
    uint32_t reserved[12];
    int (*close)(struct hw_device_t* device);

} hw_device_t;

/* 加载库，获取接口的步骤

*/
//获取HAL_MODULE_INFO_SYM的 struct hw_module_t
1，hw_get_module(ID)-->hw_get_module_by_class(const char *id, const char *path, const struct hw_module_t **pHmi){
- name = ID.[prop]	//构建库名ro.product.board,ro.hardware
- load(name){		//加载库,打开库，找到结构体HAL_MODULE_INFO_SYM
	- dlopen(path)
	- struct hw_module_t *hmi = dlsym(HAL_MODULE_INFO_SYM_AS_STR)
	}
- *pHmi = hmi
}@hardware.c

//获取struct hw_device_t
2，hmi.open-->hw_module_t->methods.open(打开模块，设置设备函数)-->设置hw_device_t

//通过struct hw_device_t获取对应的设备结构体指正。
3，hw_device_t

hardware/libhardware/hardware.c

/*
 具体的xxx硬件模块接口。获取了common指针就获取了硬件模块的指针

 hardwareComposer:
 hwc.h

 audio:
 Device.h
 StreamOut.h
 StreamIn.h

 android8.0
 audio:IDevice IStream
 
*/
struct xxx_module {
    struct hw_module_t common;
};

struct xxx_hw_device {//硬件设备的接口
    struct hw_device_t common;
    interface1;
    interface2;
    ...   
}

//硬件模块的库实现：
struct xxx_module HAL_MODULE_INFO_SYM = {
- struct hw_module_t common
}

