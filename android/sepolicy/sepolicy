/******************************
 selinux
 每个对象进程和文件被赋予安全属性(Security Context): u:r:type[:range]

 TEAC (Type Enforcement Accesc Control)
 RBAC (Role Based Accesc Control)
*/
//命令根据log生成规则
adb shell "cat /proc/kmsg | grep avc" > avc_log.txt
audit2allow -i avc_log.txt


# enforcing - SELinux security policy is enforced.
# permissive - SELinux prints warnings instead of enforcing.允许操作，但记录操作信息
# disabled - SELinux is fully disabled.
setenforce 0 / 1 //设置系统selinux是否打开

ps -Z //查看进程安全属性
ls -Z //查看文件安全属性
chcon u:object_r:vold_exec:s0  /system/bin/vold	 //设置文件security

//u:r:type[:range]
user			//用户
role 			//角色 object_r / r
type			//文件类型 / 进程标签 type/domain
range			//安全级别 Multi-Level Security(MLS)	



/*
 定义类型
 
 type关联到属性attribute后,分配给attribute的权限会作用到type上
*/
type和attribute在同一个命名空间，不能重名

type type_id [alias alias_id] [, attribute_id]			//定义一个类型，关联属性attribute_id
attribute attribute_id						//定义一个属性，可以被type关联
typeattribute type_id attribute_id1,attribute_id2,attribute_id3	//将已定义一个类型，关联到属性
typealias type_id alias alias_id				//定义别名
type_transition source_type target_type : class default_type	//type转换，一般用于进程context设置


/*
 设置文件标签

 android在filecontext中
*/

/path/to/file u:object_r:type_id:s0 //设置一个文件的scontext



/*
 设置进程标签

 android示例
*/

type xxx,domain				//android的设置
type xxx_exec, exec_type, file_type;

init_daemon_domain(xxx)			//从init执行服务

define(`init_daemon_domain', `domain_auto_trans(init, $1_exec, $1) tmpfs_domain($1)')

define(`domain_auto_trans', `
domain_trans($1,$2,$3)			//运行必要的权限
type_transition $1 $2:process $3;	//执行切换
')

define(`domain_trans', `
allow $1 $2:file { getattr open read execute map };		//允许init打开，读取，执行xxx_exec文件
allow $1 $3:process transition;					//允许init切换到xxx
allow $3 $2:file { entrypoint open read execute getattr map }	//允许xxx打开，读取，执行xxx_exec
ifelse($1, `init', `', `allow $3 $1:process sigchld;')		//New domain can send SIGCHLD to its caller.
dontaudit $1 $3:process noatsecure;				//# Enable AT_SECURE, i.e. libc secure mode.
allow $1 $3:process { siginh rlimitinh };			//# XXX dontaudit candidate but requires further study.
')


/*
 设置权限

 android在te文件中
*/
rule_name source_type target_type:object_class perm_set;

//rule_name:allow,dontaudit,auditallow,neverallow
allow  表示主体对客体执行允许的操作。
dontaudit  表示不记录违反规则的决策信息，且违反规则不影响运行。
auditallow  表示允许操作并记录访问决策信息。
neverallow neverallow的存在是在生成（编译）安全策略文件时检查allow语句是否违反了neverallow，防止由于开发人员的失误导致某些域权限过高

//操作
open create execute

//object class 一个对象拥有一些操作集合（一个文件可以读写执行）
class class_id						//定义一个class
common common_id { perm_set }				//Perm set操作的集合。create drop getattr setattr relabelfrom relabelto
class class_id [ inherits common_set ] [ { perm_set } ]	//class可执行的操作

//设置权限
allow init unlabeled:filesystem mount; 				//允许init类型对unlabeled类型的filesystem进行mount的操作 
allow init fotad:unix_stream_socket { bind create };		//允许init类型对fotad类型的unix_stream_socket 进行bind和create的操作  
neverallow { appdomain -unconfineddomain } self:capability2 *;	//绝对不允许除了unconfineddomain以外的app对self类型的capability2进行任何的操作

