/******************************
 selinux
 每个对象（进程和文件）被赋予安全属性(Security Context): u:r:type[:range]
*/
//系统中selinux设置
# enforcing - SELinux security policy is enforced.
# permissive - SELinux prints warnings instead of enforcing.允许操作，但记录操作信息
# disabled - SELinux is fully disabled.
setenforce 0 设置为permissive

//相关命令
ps -Z //查看进程
ls -Z //查看文件
chcon u:object_r:vold_exec:s0  /system/bin/vold	 //设置security

//u:r:type[:range]
u:user
r:role //角色 文件是object_r
type/domain://类型（主要描述文件）/标签（描述进程）
range:Multi-Level Security(MLS)//安全级别 s0

attribute: domain/type //类型集合


//根据log生成规则
adb shell "cat /proc/kmsg | grep avc" > avc_log.txt
audit2allow -i avc_log.txt

/******************************
 定义类型,设置文件类型,设置进程类型,设置权限
 
 SELinux Common Intermediate Language (CIL
*/

规则:
rule_name source_type target_type:object_class perm_set;

//rule_name:allow,dontaudit,auditallow,neverallow
allow  表示主体对客体执行允许的操作。
dontaudit  表示不记录违反规则的决策信息，且违反规则不影响运行。
auditallow  表示允许操作并记录访问决策信息。
neverallow neverallow的存在是在生成（编译）安全策略文件时检查allow语句是否违反了neverallow，防止由于开发人员的失误导致某些域权限过高

//设置权限
 allow init unlabeled:filesystem mount; //允许init类型对unlabeled类型的filesystem进行mount的操作 
 allow init fotad:unix_stream_socket { bind create };//允许init类型对fotad类型的unix_stream_socket 进行bind和create的操作  
 neverallow { appdomain -unconfineddomain } self:capability2 *;//绝对不允许除了unconfineddomain以外的app对self类型的capability2进行任何的操作

//定义type拥有的权限(source_type target_type)
type httpd_user_content_t, file_type, httpdcontent; //声明一个httpd_user_content_t的类型，具有file_type和httpdcontent的属性

//设置文件
/file/path u:object_r:type_id:s0 

//设置进程


//操作类型
//Perm set指得是某种Object class所拥有的操作。class:定义某一类型可执行的操作
common common_name { permission_name ... } common定义的perm set能
class class_name [ inherits common_name ] { permission_name ... }

/******************************
 编译 主要生成上下文(进程和文件的类型)，策略(*.te)

*/
file_contexts 编译生成file_contexts.bin
security_classes​，*.te,其它文件生成​ policy.conf

//编译 平台sepolicy device/xxx/common/plat_sepoliy
system/sepolicy/private/access_vectors //定义操作集

/******************************
 加载

*/
main(int argc, char** argv) {
- selinux_initialize(true)
- selinux_android_restorecon("/init", 0)
- selinux_initialize(false)
- selinux_restore_context()
}@init.cpp

selinux_initialize(bool in_kernel_domain) {
- if(in_kernel_domain){
	- selinux_load_policy-->selinux_load_split_policy
	 //是能selinux
	- bool is_enforcing = selinux_is_enforcing()
	- security_setenforce(is_enforcing)
  }else{
	- selinux_init_all_handles
  }
}

//
selinux_load_split_policy{
  //查找policy文件 "/vendor/etc/selinux/precompiled_sepolicy"	
- selinux_find_precompiled_split_policy(&precompiled_sepolicy_file)
- android::base::unique_fd fd(open(precompiled_sepolicy_file.c_str(), O_RDONLY | O_CLOEXEC | O_BINARY))	
- selinux_android_load_policy_from_fd(fd, precompiled_sepolicy_file.c_str()){
	  //设置selinux的写入目录"/sys/fs/selinux" 
	- set_selinuxmnt(SELINUXMNT)
	- void *map = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0)
	  //加载
	- security_load_policy(void *data, size_t len)
	}@android_platform.c
}@init.cpp

//将数据写入到 /sys/fs/selinux目录下
security_load_policy(void *data, size_t len){
- snprintf(path, sizeof path, "%s/load", selinux_mnt)
- write(fd, data, len)
}@load_policy.c

system/core/init/init.cpp
external/selinux/libselinux/src/android/android_platform.c
external/selinux/libselinux/src/setenforce.c
external/selinux/libselinux/src/load_policy.c


//更新policy
1. Modify the required policy source files including the relevant device policy
modules. Rebuild the kernel policy file by:
make sepolicy
2. Copy the policy file to the device (it copies the new policy to the alternate
directory so that it is picked up by the reload property):
adb push out/target/product/<device>/root/sepolicy /data/security/current
3. Then load the new policy by:
adb shell su setprop selinux.reload_policy 1
